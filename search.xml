<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux学习笔记(二)</title>
    <url>/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h3 id="Linux的实用指令"><a href="#Linux的实用指令" class="headerlink" title="Linux的实用指令"></a>Linux的实用指令</h3><h4 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h4><p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581738004881.png" alt="1581738004881"></p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">运行级别</th>
<th align="center">运行级别细节</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">关机 shutdown.target</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">单用户【找回丢失密码】emergency.target</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">多用户状态没有网络服务 rescure.target</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">多用户状态有网络服务 multi-user.target</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">系统未使用保留给用户</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">图形界面 graphical.target</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">重启系统</td>
</tr>
</tbody></table>
<p>常用的运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的<strong>id:5:initdefault:</strong>这一行中的数字</p>
<p>命令基本语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init [012356]</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581738925424.png" alt="1581738925424"></p>
<p>CentOS7发现不是想要的结果 但是 提到了如果想要修改默认的操作级别需要执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure>

<p>获得当前的运行级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></table></figure>

<p>设置默认的运行级别为 xxx :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl set-default xxx</span><br></pre></td></tr></table></figure>

<p>如果需要临时切换 直接 init + 需要切换到的数字。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>忘记root密码，可以通过进入单用户模式，然后修改root密码，因为进入单用户模式，root不需要密码就可以登录。</p>
<p>当开机时，进入引导界面时，按下 <code>e</code> 进入编辑修改界面：</p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581741679343.png" alt="1581741679343"></p>
<p>进入修改编辑界面之后，修改如下内容，然后<kbd>Ctrl</kbd>+<kbd>x</kbd>启动进入单用户界面。</p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581742575694.png" alt="1581742575694"></p>
<p>然后修改密码，如果已经开启了SElinux，则需要输入以下命令<code>touch /.autorelabel</code>，最后输入<code>exec /sbin/init</code>重启即可。</p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581742657061.png" alt="1581742657061"></p>
<p>为何需要/.autorelabel：系统是没有SELinux 的，而你刚刚更改了/etc/shadow (因为改密码啊！)， 所以『这个档案的SELinux 安全本文的特性将会被取消』喔！如果你没有让系统于开机时自动的回复SELinux 的安全本文， 你的系统将产生『无法登入』的问题(在SELinux 为Enforcing 的模式下！)加上/.autorelabel 就是要让系统在开机的时候自动的使用预设的SELinux type 重新写入SELinux 安全本文到每个档案去！</p>
<h4 id="帮助类指令"><a href="#帮助类指令" class="headerlink" title="帮助类指令"></a>帮助类指令</h4><p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。</p>
<h5 id="man指令"><a href="#man指令" class="headerlink" title="man指令"></a>man指令</h5><p>man是manual的缩写，是手册说明书的意思。</p>
<ul>
<li><p>功能描述：获得帮助信息。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man [命令或配置文件]</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man ls		&#x2F;&#x2F;查看ls的帮助信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581745778862.png" alt="1581745778862"></p>
<p>常用命令有：<code>ls -a -l</code>格式化列出包括隐藏文件在内的所有文件。</p>
<h5 id="help指令"><a href="#help指令" class="headerlink" title="help指令"></a>help指令</h5><ul>
<li><p>功能描述：获得shell内置命令的帮助信息。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help 命令</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help cd		&#x2F;&#x2F;查看cd命令的帮助信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581746301244.png" alt="1581746301244"></p>
<h4 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h4><h5 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h5><ul>
<li><p>功能描述：显示当前工作目录的绝对路径</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd		&#x2F;&#x2F;显示当前工作目录</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581746900427.png" alt="1581746900427"></p>
<h5 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h5><ul>
<li><p>功能描述：显示目录，文件大小，创建时间等。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [选项] [目录或文件]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">显示当前目录所有的文件和目录，包括隐藏的</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">以列表的方式显示信息</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">显示单位的更友好，默认是Byte</td>
</tr>
</tbody></table>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls			&#x2F;&#x2F;显示当前目录信息</span><br><span class="line">ls -a		&#x2F;&#x2F;显示当前目录信息，包括隐藏文件</span><br><span class="line">ls -la		&#x2F;&#x2F;格式化显示当前目录信息，包括隐藏文件</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581747363031.png" alt="1581747363031"></p>
<h5 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h5><ul>
<li><p>功能描述：切换到指定目录</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [参数]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用参数：绝对路径或相对路径</p>
<p>​    绝对路径：从根目录开始定位，<code>/home</code></p>
<p>​    相对路径：从当前工作目录开始定位到需要的目录，<code>../quincy</code></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cd ~或者cd</td>
<td align="center">回到自己的家目录</td>
</tr>
<tr>
<td align="center">cd ..</td>
<td align="center">回到当前目录的上一级目录</td>
</tr>
</tbody></table>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd			&#x2F;&#x2F;回到当前用户的家目录</span><br><span class="line">cd ~		&#x2F;&#x2F;同上</span><br><span class="line">cd ..		&#x2F;&#x2F;回到当前目录的上一级目录</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581748158908.png" alt="1581748158908"></p>
<h5 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h5><ul>
<li><p>功能描述：创建目录（make directory）。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir [选项] 要创建的目录</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用选项：</p>
<p>​         -p：创建多级目录</p>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;home&#x2F;dog					&#x2F;&#x2F;创建&#x2F;home&#x2F;dog目录</span><br><span class="line">mkdir -p &#x2F;home&#x2F;animal&#x2F;tiger     &#x2F;&#x2F;创建&#x2F;home&#x2F;animal&#x2F;tiger多级目录</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581749196604.png" alt="1581749196604"></p>
<h5 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h5><ul>
<li>基本语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir [选项] 要删除的空目录</span><br></pre></td></tr></table></figure>

<ul>
<li><p>功能描述：删除指定空目录。</p>
<p>rmdir删除的是空目录，如果目录中由内容将无法删除。如果删除非空目录使用<code>rm -rf /home/dog</code></p>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir &#x2F;home&#x2F;dog			&#x2F;&#x2F;删除&#x2F;home&#x2F;dog空目录</span><br><span class="line">rm -rf &#x2F;home&#x2F;dog		&#x2F;&#x2F;删除&#x2F;home&#x2F;dog目录，且不显示信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581749927984.png" alt="1581749927984"></p>
<h5 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h5><ul>
<li><p>功能描述：创建空文件</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 文件名称</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch hello.txt				&#x2F;&#x2F;在当前目录下创建hello.txt空文件</span><br><span class="line">touch ok1.txt ok2.txt		&#x2F;&#x2F;在当前目录下创建ok1.txt,ok2.txt空文件</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581750366652.png" alt="1581750366652"></p>
<h5 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h5><ul>
<li><p>功能描述：拷贝文件到指定目录</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [选项] source dest</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用选项：</p>
<p>​    -r：递归复制整个文件夹(递归单词为recursion，所以用-r)</p>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp a.txt ..&#x2F;b			&#x2F;&#x2F;拷贝a.txt文件到上级目录中的b目录下</span><br><span class="line">cp -r a&#x2F; b&#x2F; 			&#x2F;&#x2F;拷贝a文件夹到b目录下</span><br><span class="line">\cp -r a&#x2F; b&#x2F;			&#x2F;&#x2F;强制拷贝a文件夹到b目录下，不提示覆盖信息</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581751761275.png" alt="1581751761275"></p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581752063393.png" alt="1581752063393"></p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581752403224.png" alt="1581752403224"></p>
<h5 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h5><ul>
<li><p>功能描述：移除文件或目录</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [选项] 要删除的文件或目录</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-r</td>
<td align="center">递归删除整个文件夹</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">强制删除不提示</td>
</tr>
</tbody></table>
</li>
<li><p>应用实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf a				&#x2F;&#x2F;删除文件夹a</span><br><span class="line">rm a.txt				&#x2F;&#x2F;删除文件a.txt</span><br><span class="line">rm -r b					&#x2F;&#x2F;删除文件夹b，显示删除信息</span><br><span class="line">rm -f a.txt b.txt		&#x2F;&#x2F;删除文件，不显示删除信息</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581753033645.png" alt="1581753033645"></p>
<h5 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h5><ul>
<li><p>功能描述：移动文件与目录或重命名</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv oldNameFile newNameFile            &#x2F;&#x2F;重命名</span><br><span class="line">mv &#x2F;temp&#x2F;movefile &#x2F;targetFolder       &#x2F;&#x2F;移动文件</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv a.txt b.txt			&#x2F;&#x2F;将a.txt文件重命名为b.txt</span><br><span class="line">mv b.txt b				&#x2F;&#x2F;将b.txt文件移动到b目录下</span><br><span class="line">mv b.txt ..&#x2F;a.txt		&#x2F;&#x2F;将b.txt文件移动到上级目录，并重命名为a.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581754018502.png" alt="1581754018502"></p>
<h5 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h5><ul>
<li><p>功能描述：查看文件内容，不能修改，一般会带上管道命令 <code>| more</code></p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [选项] 要查看的文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用选项：</p>
<p>​    -n：显示行号。</p>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -n &#x2F;etc&#x2F;profile                   &#x2F;&#x2F;查看&#x2F;etc&#x2F;profile文件内容，带行号</span><br><span class="line">cat -n &#x2F;etc&#x2F;profile | more            &#x2F;&#x2F;分页显示，按空格换页，详情看more指令</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581754537305.png" alt="1581754537305"></p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581754550844.png" alt="1581754550844"></p>
<h5 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h5><ul>
<li><p>功能描述：</p>
<p>是一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容，并内置了若干快捷键。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more 要查看的文件</span><br></pre></td></tr></table></figure>

<ul>
<li>常用快捷键：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><kbd>Space</kbd></td>
<td align="center">向下翻一页</td>
</tr>
<tr>
<td align="center"><kbd>Enter</kbd></td>
<td align="center">向下滚动一行</td>
</tr>
<tr>
<td align="center"><kbd>q</kbd></td>
<td align="center">退出more，不在显示该文件内容</td>
</tr>
<tr>
<td align="center"><kbd>Ctrl</kbd>+<kbd>f</kbd></td>
<td align="center">向下滚动一屏</td>
</tr>
<tr>
<td align="center"><kbd>Ctrl</kbd>+<kbd>b</kbd></td>
<td align="center">返回上一屏</td>
</tr>
<tr>
<td align="center"><kbd>=</kbd></td>
<td align="center">输出当前行的行号</td>
</tr>
<tr>
<td align="center"><kbd>：</kbd>+<kbd>f</kbd></td>
<td align="center">输出文件名和当前的行号</td>
</tr>
</tbody></table>
<h5 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h5><ul>
<li><p>功能描述：</p>
<p>less指令用来分屏查看文件内容，功能与more类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，<strong>对于显示大型文件具有较高的效率</strong></p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less 要查看的文件</span><br></pre></td></tr></table></figure>

<ul>
<li>常用快捷键</li>
</ul>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><kbd>Space</kbd></td>
<td align="center">向下翻动一页</td>
</tr>
<tr>
<td align="center"><kbd>Pagedown</kbd></td>
<td align="center">向下翻动一页</td>
</tr>
<tr>
<td align="center"><kbd>Pageup</kbd></td>
<td align="center">向上翻动一页</td>
</tr>
<tr>
<td align="center"><kbd>/</kbd>+字符串</td>
<td align="center">向下搜寻【字符串】的功能，n：向下查找，N：向上查找</td>
</tr>
<tr>
<td align="center"><kbd>？</kbd>+字符串</td>
<td align="center">向上搜寻【字符串】的功能，n：向下查找，N：向上查找</td>
</tr>
<tr>
<td align="center"><kbd>q</kbd></td>
<td align="center">退出less</td>
</tr>
<tr>
<td align="center"><kbd>Enter</kbd></td>
<td align="center">向下滚动一行</td>
</tr>
</tbody></table>
<h5 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a>&gt;指令和&gt;&gt;指令</h5><ul>
<li><p>功能描述：</p>
<p><strong>&gt;</strong>输出重定向：会将原来的文件内容覆盖</p>
<p><strong>&gt;&gt;</strong>追加：不会覆盖原来的文件内容，而是追加到文件的尾部</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &gt; 文件				&#x2F;&#x2F;ls列的内容覆盖写入文件中</span><br><span class="line">ls -al &gt;&gt; 文件			&#x2F;&#x2F;ls列的内容追加到文件的末尾</span><br><span class="line">cat 文件1 &gt; 文件2		   &#x2F;&#x2F;将文件1的内容覆盖到文件2</span><br><span class="line">echo &quot;内容&quot; &gt;&gt; 文件		   &#x2F;&#x2F;将内容追加到文件中</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &gt; a.txt				&#x2F;&#x2F;ls列的内容覆盖写入文件a.txt中，如果文件不存在，则创建文件</span><br><span class="line">ls -al &gt;&gt; b.txt				&#x2F;&#x2F;ls列的内容追加到文件b.txt的末尾</span><br><span class="line">cat a.txt &gt; b.txt			&#x2F;&#x2F;将文件a.txt的内容覆盖到文件b.txt</span><br><span class="line">echo &quot;hello&quot; &gt;&gt; a.txt		&#x2F;&#x2F;将hello追加到文件a.txt的末尾</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581853342111.png" alt="1581853342111"></p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581853399689.png" alt="1581853399689"></p>
<h5 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h5><ul>
<li><p>功能描述：输出内容到控制台</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH			&#x2F;&#x2F;控制台输出环境变量</span><br><span class="line">echo &quot;hello&quot;		&#x2F;&#x2F;控制台输出文本hello</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581854454658.png" alt="1581854454658"></p>
<h5 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h5><ul>
<li><p>功能描述：用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head 文件				&#x2F;&#x2F;查看文件头10行的内容</span><br><span class="line">head -n 5 文件		&#x2F;&#x2F;查看文件头5行的内容，5可以改变为任意的行数</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -n 8 &#x2F;etc&#x2F;profile		&#x2F;&#x2F;查看&#x2F;etc&#x2F;profile前8行的文件内容</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581854732514.png" alt="1581854732514"></p>
<h5 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h5><ul>
<li><p>功能描述：用于输出文件尾部的内容，默认情况下显示文件后10行的内容</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail 文件				&#x2F;&#x2F;查看文件后10行的内容</span><br><span class="line">tail -n 5 文件		&#x2F;&#x2F;查看文件后5行的内容,5可以改变为任意的行数</span><br><span class="line">tail -f 文件			&#x2F;&#x2F;实时追踪该文件的所有更新，经常使用</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n 8 &#x2F;etc&#x2F;profile		&#x2F;&#x2F;查看&#x2F;etc&#x2F;profile后8行的文件内容</span><br><span class="line">tail -f a.txt				&#x2F;&#x2F;实时跟踪a.txt文件的变化，开两个终端</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581855932317.png" alt="1581855932317"></p>
<h5 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h5><p>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径。</p>
<ul>
<li><p>功能描述：给原文件创建一个软链接</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s [原文件或目录] [软链接名]</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;root linkToRoot			&#x2F;&#x2F;创建一个指向&#x2F;root的名为linkToRoot的软链接</span><br><span class="line">rm -rf linkToRoot				&#x2F;&#x2F;删除linkToRoot软链接</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581857768231.png" alt="1581857768231"></p>
<ul>
<li>细节说明：当使用pwd指令查看目录时，仍然看到的是软链接所在目录。</li>
</ul>
<h5 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h5><ul>
<li><p>功能描述：查看已经执行过的历史命令，也可以执行历史指令。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history				&#x2F;&#x2F;显示所有的历史命令</span><br><span class="line">history 8			&#x2F;&#x2F;显示最近使用过的8个指令</span><br><span class="line">!57					&#x2F;&#x2F;执行历史编号为57的指令</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581858403947.png" alt="1581858403947"></p>
<h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><h5 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h5><ul>
<li><p>功能描述：显示和设置当前日期</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date							&#x2F;&#x2F;显示当前时间</span><br><span class="line">date +%Y						&#x2F;&#x2F;显示当前年份</span><br><span class="line">date +%m						&#x2F;&#x2F;显示当前月份</span><br><span class="line">date +%d						&#x2F;&#x2F;显示当前是哪一天</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot;		&#x2F;&#x2F;显示年月日时分秒</span><br><span class="line">date -s 字符串时间				&#x2F;&#x2F;设置日期</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date &quot;+%Y %m %d %H:%M:%S&quot;		&#x2F;&#x2F;显示年月日时分秒，引号中的格式可以自定义</span><br><span class="line">date -s &quot;2020-01-01 10:10:10&quot;	&#x2F;&#x2F;设置日期为2020-01-01 10:10:10</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581859272543.png" alt="1581859272543"></p>
<h5 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h5><ul>
<li><p>功能描述：查看日历指令，不加选项显示本月日历</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal [选项]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-1</td>
<td align="center">只查看一个月的日历</td>
</tr>
<tr>
<td align="center">-3</td>
<td align="center">查看三个月的日历，本月和邻月</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">一个星期的第一天为周日</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">一个星期的第一天为周一</td>
</tr>
<tr>
<td align="center">-j</td>
<td align="center">本年中的第几天</td>
</tr>
<tr>
<td align="center">-V</td>
<td align="center">日历版本</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">查看帮助</td>
</tr>
<tr>
<td align="center">-y</td>
<td align="center">查看本年的日历</td>
</tr>
</tbody></table>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal						&#x2F;&#x2F;查看日历,默认本月日历</span><br><span class="line">cal -3					&#x2F;&#x2F;查看本月和邻月的日历</span><br><span class="line">cal -s					&#x2F;&#x2F;查看日历第一天为周日</span><br><span class="line">cal -m					&#x2F;&#x2F;查看日历第一点为周一</span><br><span class="line">cal -1 3 2020			&#x2F;&#x2F;查看2020年3月一个月的日历</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581859898555.png" alt="1581859898555"></p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581859917655.png" alt="1581859917655"></p>
<h4 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h4><h5 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h5><ul>
<li><p>功能描述：将从指定目录向下递归地遍历其各个子目录，将满足条件的<strong>文件或者目录</strong>显示在终端。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find [搜索范围] [选项]</span><br></pre></td></tr></table></figure>

<ul>
<li>选项说明：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-name</td>
<td align="center">按照指定的文件名查找模式查找文件</td>
</tr>
<tr>
<td align="center">-user</td>
<td align="center">查找属于指定用户的所有文件</td>
</tr>
<tr>
<td align="center">-size</td>
<td align="center">按照指定的文件大小查找文件，+n：大于；-n：大于；n：大于</td>
</tr>
</tbody></table>
<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -name a.txt			&#x2F;&#x2F;按文件名查找&#x2F;home目录下的hello.txt文件</span><br><span class="line">find &#x2F;opt -user quincy			&#x2F;&#x2F;按用户查找&#x2F;opt目录下的名为quincy的文件</span><br><span class="line">find &#x2F; -size +20M				&#x2F;&#x2F;按文件大小查找根目录下大于20M的文件</span><br><span class="line">find &#x2F; -name *.txt				&#x2F;&#x2F;查找根目录下所有.txt的文件</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581861731363.png" alt="1581861731363"></p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581861855200.png" alt="1581861855200"></p>
<h5 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h5><ul>
<li><p>功能描述：</p>
<p>可以快速定位文件路径。locate指令是利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位指定文件，无需遍历整个文件系统，查询速度快，为了保证查询结果的准确度，管理员必须定期更新locate数据库。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate 搜索文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特别说明：</p>
<p><strong>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用<code>updatedb</code>指令创建locate数据库。</strong></p>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate a.txt		&#x2F;&#x2F;定位a.txt文件所在目录</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581862999750.png" alt="1581862999750"></p>
<h5 id="grep指令和管道符号"><a href="#grep指令和管道符号" class="headerlink" title="grep指令和管道符号 |"></a>grep指令和管道符号 |</h5><ul>
<li><p>功能描述：过滤查找，管道符|，表示将前一个命令的处理结果输出传递给后面的命令处理。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep [选项] 查找内容 源文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-n</td>
<td align="center">显示匹配行及行号</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">忽略字母大小写</td>
</tr>
</tbody></table>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat a.txt | grep -ni root		&#x2F;&#x2F;在a.txt文件中，查找&quot;root&quot;所在行，并显示行号,忽略大小写</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581864595598.png" alt="1581864595598"></p>
<h4 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h4><h5 id="gzip-gunzip指令"><a href="#gzip-gunzip指令" class="headerlink" title="gzip/gunzip指令"></a>gzip/gunzip指令</h5><ul>
<li>功能描述：<strong>gzip</strong>用于压缩文件，压缩为<strong>*.gz</strong>的文件，<strong>gunzip</strong>用于解压。</li>
</ul>
<ul>
<li>基本语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip 文件					&#x2F;&#x2F;压缩文件，压缩为*.gz文件</span><br><span class="line">gunzip 文件.gz			&#x2F;&#x2F;解压*.gz文件</span><br></pre></td></tr></table></figure>

<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip a.txt				&#x2F;&#x2F;将a.txt文件进行压缩</span><br><span class="line">gunzip a.txt.gz			&#x2F;&#x2F;将a.txt.gz文件进行解压</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581909426337.png" alt="1581909426337"></p>
<ul>
<li><p>细节说明：</p>
<p>​    <strong>gzip</strong>和<strong>gunzip</strong>对文件进行压缩和解压缩之后不会保留原文件。</p>
</li>
</ul>
<h5 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip/unzip指令"></a>zip/unzip指令</h5><ul>
<li><p>功能描述：<strong>zip</strong>用于压缩文件，压缩成<strong>*.zip</strong>文件，<strong>unzip</strong>用于解压，这个在项目打包发布中很有用。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip [选项] XXX.zip 将要压缩的内容	&#x2F;&#x2F;压缩文件和目录的命令</span><br><span class="line">unzip [选项] XXX.zip				 &#x2F;&#x2F;解压缩文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>zip常用选项：</p>
<p>​        -r：递归压缩，即压缩目录；</p>
</li>
<li><p>unzip常用选项：</p>
<p>​        -d &lt;目录&gt;：指定解压后文件的存放目录</p>
</li>
<li><p>应用实例：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip a.zip a.txt			&#x2F;&#x2F;压缩a.txt文件为a.zip</span><br><span class="line">zip -r b.zip b			&#x2F;&#x2F;压缩b目录为b.zip</span><br><span class="line">unzip -d b a.zip		&#x2F;&#x2F;解压a.zip目录到目录b中</span><br><span class="line">unzip a.zip				&#x2F;&#x2F;解压a.zip文件</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581911117428.png" alt="1581911117428"></p>
<h5 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h5><ul>
<li><p>功能描述：打包指令，最后打包后的文件是<strong>*.tar.gz</strong>的文件。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar [选项] XXX.tar.gz 打包的内容		&#x2F;&#x2F;打包目录，压缩后的文件格式为*.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>选项说明：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td align="center">产生.tar打包文件</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示详细信息</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">指定压缩后的文件名</td>
</tr>
<tr>
<td align="center">-z</td>
<td align="center">打包同时压缩</td>
</tr>
<tr>
<td align="center">-x</td>
<td align="center">解压.tar文件</td>
</tr>
</tbody></table>
<ul>
<li>应用实例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf a.tar.gz a.txt b.txt		&#x2F;&#x2F;压缩a.txt和b.txt文件命名为a.tar.gz</span><br><span class="line">tar -zcvf home.tar.gz &#x2F;home&#x2F;		&#x2F;&#x2F;压缩home目录命名为home.tar.gz</span><br><span class="line">tar -zxvf a.tar.gz					&#x2F;&#x2F;解压a.tar.gz到当前目录</span><br><span class="line">tar -zxvf home.tar.gz -C a			&#x2F;&#x2F;解压home.tar.gz到a目录</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581913407055.png" alt="1581913407055"></p>
<p><img src="/2020/02/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/1581913450419.png" alt="1581913450419"></p>
<ul>
<li>细节说明：指定解压到的那个目录，事先要存在才能成功，否则会报错。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记(一)</title>
    <url>/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><p>Linux是一款操作系统，免费、开源、安全、高效、稳定，处理高并发非常强悍，现在很多的企业级的项目都部署到Linux/Unix服务器运行。</p>
<p>Linux主要的发行版本：Ubuntu、RedHat、CentOS、Suse、OpenSuse、红旗Linux、Deepin、Fedora。</p>
<p>难点：虚拟机的网络连接的三种形式的说明</p>
<p>1、<strong>桥连接</strong>：虚拟机中的操作系统可以和其它的系统同行，但是可能造成ip冲突。</p>
<p>2、<strong>NAT</strong>：网络地址转换方式，可以访问外网，不会造成ip冲突。</p>
<p>3:、<strong>主机模式</strong>：你的虚拟机是一个独立的主机，不能访问外网。</p>
<a id="more"></a>

<p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581575801300.png" alt="1581575801300"></p>
<p><strong>Kdump</strong>：系统崩溃转存机制。</p>
<h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。<strong>在Linux世界中中，一切皆文件</strong></p>
<p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581579382211.png" alt="1581579382211"></p>
<h4 id="具体的目录结构："><a href="#具体的目录结构：" class="headerlink" title="具体的目录结构："></a>具体的目录结构：</h4><p><code>/bin：(/usr/bin、/usr/local/bin)</code><strong>重点</strong></p>
<ul>
<li>是Binary的缩写。这个目录存放着最经常使用的命令。</li>
</ul>
<p><code>/sbin：(/usr/sbin、/usr/local/sbin)</code></p>
<ul>
<li>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
</ul>
<p><code>/home：</code><strong>重点</strong></p>
<ul>
<li>存放普通用户的主目录，在Linux中的每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
</ul>
<p><code>/root：</code><strong>重点</strong></p>
<ul>
<li>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
</ul>
<p><code>/lib</code>：</p>
<ul>
<li>系统开机所需要最基本的动态链接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用的这些共享库</li>
</ul>
<p><code>/lost+found</code>：</p>
<ul>
<li>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</li>
</ul>
<p><code>/etc：</code><strong>重点</strong></p>
<ul>
<li>所有的系统管理所需要的的配置文件和子目录</li>
</ul>
<p><code>/usr</code>：<strong>重点</strong></p>
<ul>
<li>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</li>
</ul>
<p><code>/boot</code>：<strong>重点</strong></p>
<ul>
<li>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
</ul>
<p><code>/proc</code>：【别动】</p>
<ul>
<li>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</li>
</ul>
<p><code>/srv</code>：【别动】</p>
<ul>
<li>service缩写，该目录存放一些服务启动之后需要提取的数据。</li>
</ul>
<p><code>/sys</code>：【别动】</p>
<ul>
<li>这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统。</li>
</ul>
<p><code>/tmp</code>：</p>
<ul>
<li>这个目录是用来存放一些临时文件的。</li>
</ul>
<p><code>/dev</code>：</p>
<ul>
<li>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</li>
</ul>
<p><code>/media</code>：<strong>重点</strong></p>
<ul>
<li>Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下。</li>
</ul>
<p><code>/mnt</code>：<strong>重点</strong></p>
<ul>
<li>系统提供该目录是为了让用户临时挂载别的文件系统，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以了查看里面的内容了。(例如win和linux的共享文件夹)</li>
</ul>
<p><code>/opt</code>：</p>
<ul>
<li>这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。</li>
</ul>
<p><code>/usr/local</code>：<strong>重点</strong></p>
<ul>
<li>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</li>
</ul>
<p><code>/var</code>：<strong>重点</strong></p>
<ul>
<li>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</li>
</ul>
<p><code>/selinux</code>【security-enhanced linux】：</p>
<ul>
<li>SELinux是一种安全子系统，它能控制程序只能访问特定文件。</li>
</ul>
<h4 id="总结Linux目录树"><a href="#总结Linux目录树" class="headerlink" title="总结Linux目录树"></a>总结Linux目录树</h4><ol>
<li>Linux的目录中有且只有一个根目录 /。</li>
<li>Linux的各个目录存放的内容是规划好的，不用乱放文件。</li>
<li>Linux是以文件的形式管理我们的设备，因此Linux系统，一切皆为文件。</li>
</ol>
<h3 id="Linux实操vi和vim编辑器"><a href="#Linux实操vi和vim编辑器" class="headerlink" title="Linux实操vi和vim编辑器"></a>Linux实操vi和vim编辑器</h3><p><strong>VI</strong>：所有的Linux系统都会内建vi文本编辑器</p>
<p><strong>VIM</strong>：具有程序编程的能力，可以看做是vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补充、编译等方便编程的功能特别丰富。</p>
<h4 id="VI和VIM的三中常见模式"><a href="#VI和VIM的三中常见模式" class="headerlink" title="VI和VIM的三中常见模式"></a>VI和VIM的三中常见模式</h4><h5 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h5><p>在正常模式下，我们可以使用快捷键。以Vim打开一个文件就直接进入一般模式(这是默认的模式)。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】【删除整行】来处理文档内容，也可以使用【复制粘贴】来处理文件数据。</p>
<h5 id="插入模式-编辑模式"><a href="#插入模式-编辑模式" class="headerlink" title="插入模式/编辑模式"></a>插入模式/编辑模式</h5><p>在该模式下，程序员可以输入内容。按下i,I,o,O,a,A,r,R等任一个字母之后才会进入编辑模式，一般来说按i即可。</p>
<h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><p>在该模式当中，可以提供你相关的指令，完成读取、存盘、替换、离开vim、显示行号等的动作。</p>
<h5 id="三种模式转换图"><a href="#三种模式转换图" class="headerlink" title="三种模式转换图"></a>三种模式转换图</h5><p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581651479320.png" alt="1581651479320"></p>
<h4 id="快捷键的使用"><a href="#快捷键的使用" class="headerlink" title="快捷键的使用"></a>快捷键的使用</h4><ol>
<li>拷贝当前行 yy，拷贝当前行向下的5行 【5yy】，并粘贴【p】</li>
<li>删除当前行 dd，删除当前行向下的5行 【5dd】</li>
<li>在文件中查找某个单词【命令行下/关键字，回车查找，输入n就是查找下一个，N查找下一个】</li>
<li>设置文件的行号，取消文件的行号。【命令行下：set nu和：set nonu】</li>
<li>编辑/etc/profile文件，使用快捷键到文本的最末行【G】和最首行【gg】</li>
<li>在一个文件中输入“hello”，然后又撤销这个动作 【u】</li>
<li>编辑/etc/profile文件，并将光标移动到20行 【shift+g】:set nu    20    shift+g</li>
</ol>
<h4 id="键盘布局"><a href="#键盘布局" class="headerlink" title="键盘布局"></a>键盘布局</h4><p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581654062434.png" alt="1581654062434"></p>
<h3 id="Linux开机、重启和用户登录注销"><a href="#Linux开机、重启和用户登录注销" class="headerlink" title="Linux开机、重启和用户登录注销"></a>Linux开机、重启和用户登录注销</h3><h4 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">shutdown -h now</td>
<td align="center">立刻进行关机</td>
</tr>
<tr>
<td align="center">shutdown -h 1</td>
<td align="center">1分钟后会关机</td>
</tr>
<tr>
<td align="center">shutdown -r now</td>
<td align="center">现在重新启动计算机</td>
</tr>
<tr>
<td align="center">halt</td>
<td align="center">关机，作用和上面一样</td>
</tr>
<tr>
<td align="center">reboot</td>
<td align="center">现在重新启动计算机</td>
</tr>
<tr>
<td align="center">sync</td>
<td align="center">把内存的数据同步到磁盘</td>
</tr>
</tbody></table>
<h5 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h5><p>​    不管是重启系统还是关闭系统，首先要运行<strong>sync</strong>命令，把内存中的数据写到磁盘中。</p>
<h4 id="用户的登录和注销"><a href="#用户的登录和注销" class="headerlink" title="用户的登录和注销"></a>用户的登录和注销</h4><p>登录时尽量少用root账号登录，因为他是系统管理员，最大的权限，避免操作失误，可以利用普通用户登录，登录后再用“su-用户名”命令来切换成系统管理员身份。</p>
<p>在提示符下输入logout即可注销用户（注意：logout注销指令在图形运行级别无效，在运行级别3下有效）</p>
<h3 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h3><p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581655913104.png" alt="1581655913104"></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统；</li>
<li>Linux的用户需要至少要属于一个组；</li>
<li>cd 表示change directory ，切换目录。</li>
</ol>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd [选项] 用户名</span><br></pre></td></tr></table></figure>

<h5 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a>细节说明</h5><ol>
<li>当创建用户成功后，会自动的创建和用户同名的家目录；</li>
<li>也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录；</li>
<li>passwd修改指定用户名密码</li>
</ol>
<h5 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h5><p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581657316316.png" alt="1581657316316"></p>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><h5 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel 用户名				&#x2F;&#x2F;删除用户，保留家目录</span><br><span class="line">userdel -r 用户名			&#x2F;&#x2F;删除用户以及用户主目录</span><br></pre></td></tr></table></figure>

<h5 id="细节说明-1"><a href="#细节说明-1" class="headerlink" title="细节说明"></a>细节说明</h5><p>​    删除用户时，一般不会将家目录删除。</p>
<h4 id="查询切换用户"><a href="#查询切换用户" class="headerlink" title="查询切换用户"></a>查询切换用户</h4><h5 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure>

<h5 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h5><p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581662795672.png" alt="1581662795672"></p>
<h5 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h5><p>在操作Linux时，如果当前用户的权限不够，可以通过su-指令，切换到高权限用户，比如root。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - 切换的用户名</span><br></pre></td></tr></table></figure>

<h5 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h5><p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581663195121.png" alt="1581663195121"></p>
<h5 id="细节说明-2"><a href="#细节说明-2" class="headerlink" title="细节说明"></a>细节说明</h5><ol>
<li>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</li>
<li>当需要返回到原来用户时，使用exit指令。</li>
</ol>
<h5 id="查看当前用户-登录用户"><a href="#查看当前用户-登录用户" class="headerlink" title="查看当前用户/登录用户"></a>查看当前用户/登录用户</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami或者who am i</span><br></pre></td></tr></table></figure>

<h4 id="组的管理"><a href="#组的管理" class="headerlink" title="组的管理"></a>组的管理</h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p>
<h5 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure>

<h5 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure>

<h5 id="添加用户时直接加上组"><a href="#添加用户时直接加上组" class="headerlink" title="添加用户时直接加上组"></a>添加用户时直接加上组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -g 组名 用户名</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581664174728.png" alt="1581664174728"></p>
<h5 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -g 新的用户组 用户名</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581664589196.png" alt="1581664589196"></p>
<h4 id="用户和组的配置文件"><a href="#用户和组的配置文件" class="headerlink" title="用户和组的配置文件"></a>用户和组的配置文件</h4><h5 id="用户和组相关的文件"><a href="#用户和组相关的文件" class="headerlink" title="用户和组相关的文件"></a>用户和组相关的文件</h5><p><strong><code>/etc/passwd</code>文件</strong></p>
<p>​    用户(user)的配置文件，记录用户的各种信息</p>
<p>​    每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：家目录：登录Shell</p>
<p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581665997527.png" alt="1581665997527"></p>
<p><strong><code>/etc/shadow</code>文件</strong></p>
<p>​    口令的配置文件</p>
<p>​    每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>
<p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/D:%5Cblog%5Cblog%5Csource_posts%5CLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%5C1581666161774.png" alt="1581666161774"></p>
<p><strong><code>/etc/group</code>文件</strong></p>
<p>​    组(group)的配置文件，记录Linux包含的组的信息</p>
<p>​    每行的含义：组名：口令：组标识号：组内用户列表</p>
<p><img src="/2020/02/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/1581666340063.png" alt="1581666340063"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>开发常用IDE工具的破解</title>
    <url>/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<p>对于广大程序员来说，集成开发环境（IDE）在软件开发过程中使用非常的广泛，他能提高程序员的软件开发效率。但是对于倾向于开源的程序员来说，收费的IDE就没有那么的友好，所以就有很多人进行破解或者使用别人的注册码，应用于自己的开发过程中。下面我自己总结了一些主流的IDE工具的破解。</p>
<a id="more"></a>

<h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><p>不知道大家有没有和我遇到一样的情况，最新的一些破解方法都不能破解IDEA为永久，都是有限期的使用，我找到最新的能破解最久的版本<code>IntelliJ IDEA 2018.1.2 x64</code>，下面我们就进行破解。</p>
<p>首先下载安装<code>IntelliJ IDEA 2018.1.2 x64</code>开发工具，<a href="https://pan.baidu.com/s/1ZNnrKaWRYd3uS3cM3s_CcQ" target="_blank" rel="noopener">软件网盘自取，提取码：jcvg</a> 安装完成之后打开进入软件，先选择免费使用。</p>
<p>接下来下载<a href="https://pan.baidu.com/s/1tqFn8mMg1WBN-t6GKn8E9Q" target="_blank" rel="noopener">破解补丁，提取码：kamr</a>，将下载好的破解补丁放到<code>IntelliJ IDEA 2018.1.2 x64</code>安装目录中的<code>bin</code>目录下，如下图所示：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/IDEA%E8%A1%A5%E4%B8%81.jpg" alt="IDEA补丁" title="IDEA补丁"></p>
<p>然后修改<code>bin</code>目录下的配置文件<code>idea.exe.vmoptions</code> 和  <code>idea64.exe.vmoptions</code>，如下图所示：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/IDEAconfig.jpg" alt="IDEA配置" title="IDEA配置"></p>
<p>在这两个文件中添加破解补丁的路径，譬如我的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:E:\IntelliJ IDEA 2018.1.2\bin\JetbrainsCrack-3.1-release-enc.jar</span><br></pre></td></tr></table></figure>

<p>最后打开IDEA在菜单栏找到<code>Help</code>，点击它，找到并点击<code>Register</code>，选择<code>Activation code</code>，然后将激活码粘贴到下面的输入框中，如下图：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/IDEA.jpg" alt="IDEA" title="IDEA配置"></p>
<p>激活码如下，粘贴到上述的输入框中即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThisCrackLicenseId-&#123;</span><br><span class="line">&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,</span><br><span class="line">&quot;licenseeName&quot;:&quot;你自己随便取一个&quot;,</span><br><span class="line">&quot;assigneeName&quot;:&quot;&quot;,</span><br><span class="line">&quot;assigneeEmail&quot;:&quot;随便填一个邮箱&quot;,</span><br><span class="line">&quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;,</span><br><span class="line">&quot;checkConcurrentUse&quot;:false,</span><br><span class="line">&quot;products&quot;:[</span><br><span class="line">&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;,</span><br><span class="line">&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2100-12-31&quot;&#125;</span><br><span class="line">],</span><br><span class="line">&quot;hash&quot;:&quot;2911276&#x2F;0&quot;,</span><br><span class="line">&quot;gracePeriodDays&quot;:7,</span><br><span class="line">&quot;autoProlongated&quot;:false&#125;</span><br></pre></td></tr></table></figure>

<p>这样IDEA破解就完成了，我们可以通过点击<code>Help</code>中的<code>About</code>发现已经破解到2100年了。</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/IDEAAbout.jpg" alt="IDEA" title="About"></p>
<h3 id="GoLand"><a href="#GoLand" class="headerlink" title="GoLand"></a>GoLand</h3><p>首先下载安装<code>JetBrains GoLand 2019.1.3 x64</code>开发工具，<a href="https://pan.baidu.com/s/1zSQ79BgDq0l64utQS2V8qA" target="_blank" rel="noopener">软件网盘自取，提取码：tf2n</a> 安装完成之后打开进入软件，先选择免费使用。</p>
<p>接下来下载<a href="https://pan.baidu.com/s/1ALNdGIIWalNnBy1EO-uL9Q" target="_blank" rel="noopener">破解补丁，提取码：q3ry</a>，将下载好的破解补丁放到<code>JetBrains GoLand 2019.1.3 x64</code>安装目录中的<code>bin</code>目录下，如下图所示：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/GoLand%E8%A1%A5%E4%B8%81.jpg" alt="GoLand补丁" title="GoLand补丁"></p>
<p>然后修改<code>bin</code>目录下的配置文件<code>goland.exe.vmoptions</code> 和  <code>goland64.exe.vmoptions</code>，如下图所示：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/GoLandconfig.jpg" alt="GoLand配置" title="GoLand配置"></p>
<p>在这两个文件中添加破解补丁的路径，譬如我的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:E:\GoLand 2019.1.3\bin\jetbrains-agent.jar</span><br></pre></td></tr></table></figure>

<p>最后打开GoLand在菜单栏找到<code>Help</code>，点击它，找到并点击<code>Register</code>，选择<code>Activation code</code>，然后将激活码粘贴到下面的输入框中，如下图：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/GoLand.jpg" alt="GoLand" title="GoLand配置"></p>
<p>激活码如下，粘贴到上述的输入框中即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">520E5894E2-eyJsaWNlbnNlSWQiOiI1MjBFNTg5NEUyIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-DZ&#x2F;oNHBfyho0XrrCJJvAOKg5Q1tLBgOdbCmzCKwkuM+Yryce0RoOi3OOmH6Ba&#x2F;uTcCh&#x2F;L37meyD0FJdJIprv59y4+n+k2kIeF&#x2F;XKrKqg0dEsDUQRw0lUqqMt99ohqa+zmbJ44Yufdwwx&#x2F;F1CtoRGvEQ2Mn0QjuqRoZJZ3wiT5Am22JiJW8MaNUl3wg9YPj+OPGARKKJUdUJ0NGUDQBcBAv5ds8LhbSbJSbPkbkwH&#x2F;a1QMz4nEdn6lRDKI1aFIn43QhBSCFqvUq6TPJlbIJ0ZjE+PyZjHFBKCgkry0DHPXU2BbtIZPsksQnN3fx240a9K6sN7peZnLpEoMoq23FEz4g&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>这样GoLand破解就完成了，我们可以通过点击<code>Help</code>中的<code>About</code>发现已经破解到2089年了。</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/GoLandAbout.jpg" alt="Goland" title="About"></p>
<h3 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h3><p>首先下载安装<code>JetBrains PyCharm 2019.2.3 x64</code>开发工具，<a href="https://pan.baidu.com/s/1mKMr3XVdflszqYF4vjxUnA" target="_blank" rel="noopener">软件网盘自取，提取码：9pj4</a> 安装完成之后打开进入软件，先选择免费使用。</p>
<p>接下来下载<a href="https://pan.baidu.com/s/1PxCem7MZ5w_ffQGnUHhwrw" target="_blank" rel="noopener">破解补丁，提取码：nh5v</a>，将下载好的破解补丁放到<code>JetBrains PyCharm 2019.2.3 x64</code>安装目录中的<code>bin</code>目录下，如下图所示：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/PyCharm%E8%A1%A5%E4%B8%81.jpg" alt="PyCharm补丁" title="PyCharm补丁"></p>
<p>然后修改<code>bin</code>目录下的配置文件 <code>pycharm64.exe.vmoptions</code>，如下图所示：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/PyCharmconfig.jpg" alt="PyCharm配置" title="PyCharm配置"></p>
<p>在这两个文件中添加破解补丁的路径，譬如我的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:E:\PyCharm 2019.2.3\bin\jetbrains-agent.jar</span><br></pre></td></tr></table></figure>

<p>注意需要在Pycharm中的<code>Help</code>中的<code>Edit Custom VM Options</code>文件配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:E:\PyCharm 2019.2.3\bin\jetbrains-agent.jar</span><br></pre></td></tr></table></figure>

<p>最后打开PyCharm在菜单栏找到<code>Help</code>，点击它，找到并点击<code>Register</code>，选择<code>Activation code</code>，然后将激活码粘贴到下面的输入框中，如下图：</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/PyCharm.jpg" alt="PyCharm" title="PyCharm配置"></p>
<p>激活码如下，粘贴到上述的输入框中即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">520E5894E2-eyJsaWNlbnNlSWQiOiI1MjBFNTg5NEUyIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-DZ&#x2F;oNHBfyho0XrrCJJvAOKg5Q1tLBgOdbCmzCKwkuM+Yryce0RoOi3OOmH6Ba&#x2F;uTcCh&#x2F;L37meyD0FJdJIprv59y4+n+k2kIeF&#x2F;XKrKqg0dEsDUQRw0lUqqMt99ohqa+zmbJ44Yufdwwx&#x2F;F1CtoRGvEQ2Mn0QjuqRoZJZ3wiT5Am22JiJW8MaNUl3wg9YPj+OPGARKKJUdUJ0NGUDQBcBAv5ds8LhbSbJSbPkbkwH&#x2F;a1QMz4nEdn6lRDKI1aFIn43QhBSCFqvUq6TPJlbIJ0ZjE+PyZjHFBKCgkry0DHPXU2BbtIZPsksQnN3fx240a9K6sN7peZnLpEoMoq23FEz4g&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>这样PyCharm破解就完成了，我们可以通过点击<code>Help</code>中的<code>About</code>发现已经破解到2089年了。</p>
<p><img src="/2020/01/24/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8IDE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%A7%A3/PyCharmAbout.jpg" alt="PyCharm" title="About"></p>
]]></content>
      <categories>
        <category>破解</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Next的基本安装与部署(三)</title>
    <url>/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/</url>
    <content><![CDATA[<p>一些简单Next主题优化已经配置的差不多了，接下来我们进行一些Next主题高级的优化，有些需要用到第三方的服务。</p>
<a id="more"></a>

<h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>busuanzi_count</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>

<p>然后修改主题目录下的<code>layout\_third-party\statistics</code>目录下的<code>busuanzi-counter.swig</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.busuanzi_count.enable %&#125;</span><br><span class="line">&lt;div class&#x3D;&quot;busuanzi-count&quot;&gt;</span><br><span class="line">  &lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;site-uv&quot; title&#x3D;&quot;&#123;&#123; __(&#39;footer.total_visitors&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &amp;nbsp;本站访客数&amp;nbsp;&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人&lt;&#x2F;span&gt; </span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;site-pv&quot; title&#x3D;&quot;&#123;&#123; __(&#39;footer.total_views&#39;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &amp;nbsp;本站总访问量&amp;nbsp;&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次&lt;&#x2F;span&gt;  </span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>配置运行，网站底部结果如下所示：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Busuanzi.jpg" alt="Busuanzi" title="Busuanzi"></p>
<h3 id="文章字数与阅读时间"><a href="#文章字数与阅读时间" class="headerlink" title="文章字数与阅读时间"></a>文章字数与阅读时间</h3><p>新版本的Next用<code>symbols-count-time</code>替换了<code>word-count</code>，所以首先安装<code>symbols-count-time</code>依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>symbols_count_time</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: true</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>

<p>配置效果如下：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Symbols-count.jpg" alt="Symbols-count" title="Symbols-count"></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>先安装搜索依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>local_search</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>

<p>最后打开站点配置文件<code>_config.xml</code>任意地方配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>配置效果如下图所示：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Search1.jpg" alt="Search" title="Search"></p>
<p>点击搜索：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Search2.jpg" alt="Symbols-count" title="Search"></p>
<h3 id="Github-Fork"><a href="#Github-Fork" class="headerlink" title="Github Fork"></a>Github Fork</h3><p>打开主题根目录，打开<code>layout</code>下的<code>_layout.swig</code>文件，在 <div class="headband"></div> 下面复制下面的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/yourname"</span> <span class="attr">class</span>=<span class="string">"github-corner"</span> <span class="attr">aria-label</span>=<span class="string">"View source on GitHub"</span>&gt;</span><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"80"</span> <span class="attr">height</span>=<span class="string">"80"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 250 250"</span> <span class="attr">style</span>=<span class="string">"fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">style</span>=<span class="string">"transform-origin: 130px 106px;"</span> <span class="attr">class</span>=<span class="string">"octo-arm"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">class</span>=<span class="string">"octo-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;<span class="keyword">@keyframes</span> octocat-wave&#123;0%,100%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">0</span>)&#125;20%,60%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(-<span class="number">25deg</span>)&#125;40%,80%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">10deg</span>)&#125;&#125;<span class="keyword">@media</span> (<span class="attribute">max-width:</span><span class="number">500px</span>)&#123;<span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:none&#125;<span class="selector-class">.github-corner</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将<a>标签里的链接替换为自己的<code>github</code>的地址即可。</a></p>
<p>配置运行结果如下图所示：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Github.jpg" alt="Github" title="Github"></p>
<h3 id="文章结束标记"><a href="#文章结束标记" class="headerlink" title="文章结束标记"></a>文章结束标记</h3><p>为了方便，我添加了博文结束标记，在主题根目录下的<code>layout/_macro</code>文件夹下新建<code>passage-end-tag.swig</code>文件，添加如下代码至文件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span>-------------本文结束<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后打开在主题根目录下的<code>layout/_macro</code>文件夹下的<code>post.swig</code>文件，在 <strong>END POST BODY</strong> 之前添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文章结束标记--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include 'passage-end-tag.swig' %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，运行效果如下图所示：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/End.jpg" alt="End" title="End"></p>
<h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>我这里使用的是<a href="http://livere.com/" target="_blank" rel="noopener">来必力</a>第三方评论系统，首先注册登陆官网，然后点击安装，city为免费版，然后就可以拿到应用的ID，位置如下图所示：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Livere.jpg" alt="Livere" title="Livere"></p>
<p>复制拿到额ID，打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>livere_uid</code>关键字，并配置自己的ID即可。配置完运行效果如下所示：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Comments.jpg" alt="Comments" title="Comments"></p>
<h3 id="部署至Github"><a href="#部署至Github" class="headerlink" title="部署至Github"></a>部署至Github</h3><p>首先在自己的Github仓库创建一个github仓库，仓库名为<code>yourname.github.io</code>，yourname是你的Github用户名，如下图所示：</p>
<p><img src="/2020/01/15/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%89)/Repo.jpg" alt="Repo" title="Repo"></p>
<p>创建完成之后，复制创建好的仓库的地址，然后打开站点配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>deploy</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>将<code>yourname</code>替换为你自己的用户名即可。</p>
<p>然后回到站点的根目录，右键<code>git bash</code>启动<code>git</code>，然后依次输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo cl &#x2F;&#x2F;清理文件</span><br><span class="line">hexo g  &#x2F;&#x2F;生成文件</span><br><span class="line">hexo d  &#x2F;&#x2F;部署到github目标仓库中</span><br></pre></td></tr></table></figure>

<p>最后在浏览器中输入<code>yourname.github.io</code>，就可以访问我们自己的博客了。开心！</p>
<p>至此，我们自己的博客就搭建完成了。之后，我们就可以开始专注于写自己的技术博客，一起分享，一起进步。</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Next的基本安装与部署(二)</title>
    <url>/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/</url>
    <content><![CDATA[<p>安装完Hexo博客环境，我们就开始进行选择自己喜欢的博客进行优化。</p>
<a id="more"></a>

<h2 id="选择theme"><a href="#选择theme" class="headerlink" title="选择theme"></a>选择theme</h2><p>首先去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo的主题官网</a>选择自己喜欢的 theme，我这里选择的是Next主题，我感觉这个主题比较的简约，比较适合我的为胃口。</p>
<p>然后<code>git clone</code>得到next博客主题：(这个版本是v5.1.2)，<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">详细内容可查看</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>这个是最新版，以后更新可以直接<code>git pull</code>：<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">详细内容可查看</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<h2 id="修改theme"><a href="#修改theme" class="headerlink" title="修改theme"></a>修改theme</h2><p>打开站点配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>theme</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>然后启动运行一下，就可以看到Next的博客界面，运行过程在<a href="https://quincyshen.github.io/2020/01/12/Next的基本安装与部署(一)">Next的基本安装与部署(一)</a>有说明。</p>
<h2 id="优化Next主题"><a href="#优化Next主题" class="headerlink" title="优化Next主题"></a>优化Next主题</h2><p>启用了Next主题之后，我们就可以开始对Next主题进行优化了。</p>
<h3 id="Next内置主题"><a href="#Next内置主题" class="headerlink" title="Next内置主题"></a>Next内置主题</h3><p>打开站点配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>schemes</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>这四种主题自己挑选一个自己喜欢的启用即可，我这里启用了最后的 Gemini 的内置主题。</p>
<h3 id="主题语言"><a href="#主题语言" class="headerlink" title="主题语言"></a>主题语言</h3><p>打开站点配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>language</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br><span class="line">或 language: zh-Hans(旧版本)</span><br></pre></td></tr></table></figure>

<h3 id="网站标题、作者"><a href="#网站标题、作者" class="headerlink" title="网站标题、作者"></a>网站标题、作者</h3><p>打开站点配置文件 <code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>title</code>和<code>author</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Calm down Code on</span><br><span class="line">author: Quincy</span><br></pre></td></tr></table></figure>

<h3 id="作者头像"><a href="#作者头像" class="headerlink" title="作者头像"></a>作者头像</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>avatar</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # 设置图片路径</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.jpg</span><br><span class="line">  # 设置图片为圆形</span><br><span class="line">  rounded: true</span><br><span class="line">  # 设置图片可以旋转</span><br><span class="line">  rotated: true</span><br></pre></td></tr></table></figure>

<p>头像图片放置在主题目录中<code>themes\next\source\images</code>文件夹下，可以自行改名。</p>
<h3 id="启用menu"><a href="#启用menu" class="headerlink" title="启用menu"></a>启用menu</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>menu</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>

<p>启用效果如下图：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Menu.jpg" alt="Menu" title="Menu"></p>
<p>这里仅开启了首页、关于、标签、分类、归档的菜单，其他菜单可以根据自己的需求自己添加。</p>
<h3 id="增加标签、分类页"><a href="#增加标签、分类页" class="headerlink" title="增加标签、分类页"></a>增加标签、分类页</h3><p>打开站点文件夹，右键 <code>git bash</code> ,输入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加 categories</span><br><span class="line">hexo n page categories</span><br><span class="line">&#x2F;&#x2F;添加 tags</span><br><span class="line">hexo n page tags</span><br><span class="line">&#x2F;&#x2F;添加 about</span><br><span class="line">hexo n page about</span><br></pre></td></tr></table></figure>

<p>然后在站点主文件夹下的 source 目录下生成了 about、categories、tags 三个文件夹，如图：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Source.jpg" alt="Source" title="Soource"></p>
<p>点开三个文件夹，分别有一个 <code>index.md</code>文件，点开编辑：</p>
<p>categories 里的 <code>index.md</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2020-01-10 14:37:30</span><br><span class="line">type: categories</span><br></pre></td></tr></table></figure>

<p>tags 里的 <code>index.md</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2020-01-10 14:37:30</span><br><span class="line">type: tags</span><br></pre></td></tr></table></figure>

<p>about 里的 <code>index.md</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 关于</span><br><span class="line">date: 2020-01-10 14:37:30</span><br><span class="line">type: about</span><br></pre></td></tr></table></figure>

<p>这样在新增博文时，添加标签和分类时就会自动关联。</p>
<p>点击分类菜单可以看到，如图：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Categories.jpg" alt="Categories" title="Categories"></p>
<p>点击标签菜单可以看到，如图：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Tags.jpg" alt="Tags" title="Tags"></p>
<h3 id="标签样式"><a href="#标签样式" class="headerlink" title="标签样式"></a>标签样式</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>tag_icon</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Use icon instead of the symbol # to indicate the tag at the bottom of the post</span><br><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>

<p>更改为自带的标签样式，如下图：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Tagscss.jpg" alt="Tags style" title="Tags Style"></p>
<h3 id="新增博文"><a href="#新增博文" class="headerlink" title="新增博文"></a>新增博文</h3><p>打开站点文件夹，右键 <code>git bash</code> ,输入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n next</span><br></pre></td></tr></table></figure>

<p>然后在站点主文件夹下的 <code>source/_post</code> 目录下生成了<code>next.md</code>文件，打开编辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: next</span><br><span class="line">date: 2020-01-10 14:42:06</span><br><span class="line">tags: </span><br><span class="line">	- next</span><br><span class="line">	- Hexo</span><br><span class="line">categories: next</span><br></pre></td></tr></table></figure>

<p>然后编译启动运行，如图：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Next.jpg" alt="Next" title="Next"></p>
<h3 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>social</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  #GitHub: https:&#x2F;&#x2F;github.com&#x2F;yourname || github</span><br><span class="line">  #E-Mail: mailto:yoursite || envelope</span><br><span class="line">  #Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || weibo</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter</span><br><span class="line">  #FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname || facebook</span><br><span class="line">  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || stack-overflow</span><br><span class="line">  #YouTube: https:&#x2F;&#x2F;youtube.com&#x2F;yourname || youtube</span><br><span class="line">  #Instagram: https:&#x2F;&#x2F;instagram.com&#x2F;yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br><span class="line">  #RSS: &#x2F;atom.xml || rss</span><br></pre></td></tr></table></figure>

<p>根据自己的需求启用需要的社交链接，方便他人关注与联系。</p>
<p>启用后的效果如下所示：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Social.jpg" alt="Social" title="Social"></p>
<p>还可以改变社交链接的样式，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>social_icons</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">social_icons:</span><br><span class="line">  enable: true #启用</span><br><span class="line">  icons_only: false #仅显示图标</span><br><span class="line">  transition: false #</span><br></pre></td></tr></table></figure>

<h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>links</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">links:</span><br><span class="line">  yourname: http://yoursite.com</span><br></pre></td></tr></table></figure>

<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>reward</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Reward (Donate)</span><br><span class="line"># Front-matter variable (unsupport animation).</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 你的鼓励,是我前进最大的动力！</span><br><span class="line"></span><br><span class="line"># 打赏图片</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure>

<p>在Next主题文件下的<code>source/images</code>下的<code>wechatpay.png</code>和<code>alipay.png</code>替换为自己的微信支付宝收款二维码。</p>
<h3 id="侧边栏进度条"><a href="#侧边栏进度条" class="headerlink" title="侧边栏进度条"></a>侧边栏进度条</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>back2top</code>关键字，并配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>

<p>配置效果如下图所示：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Back2Top.jpg" alt="Back to Top" title="Back2Top"></p>
<h3 id="顶部阅读进度"><a href="#顶部阅读进度" class="headerlink" title="顶部阅读进度"></a>顶部阅读进度</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>reading_progress</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: "#37c6c0"</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>

<p>启用效果如下图所示：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/TopProgress.jpg" alt="Progress" title="TopProgress"></p>
<h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>creative_commons</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span><br><span class="line"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span><br><span class="line"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<p>配置效果如图所示：</p>
<p><img src="/2020/01/13/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%BA%8C)/Copyright.jpg" alt="Copyright" title="Copyright"></p>
<h3 id="隐藏底部主题与强力驱动"><a href="#隐藏底部主题与强力驱动" class="headerlink" title="隐藏底部主题与强力驱动"></a>隐藏底部主题与强力驱动</h3><p>打开Next主题配置文件<code>_config.xml</code>，输入<kbd>Ctrl</kbd> + <kbd>F</kbd>，搜索<code>powered</code>关键字，并配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">powered:</span><br><span class="line">   # Hexo link (Powered by Hexo).</span><br><span class="line">   enable: false</span><br><span class="line">   # Version info of Hexo after Hexo link (vX.X.X).</span><br><span class="line">   version: false</span><br><span class="line"></span><br><span class="line">theme:</span><br><span class="line">   # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">   enable: false</span><br><span class="line">   # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">   version: false</span><br></pre></td></tr></table></figure>

<p>这样简单的基本安装与部署就完成了，接下来我们进行一些高级优化。</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Next的基本安装与部署(一)</title>
    <url>/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/</url>
    <content><![CDATA[<p>一直想搭建一个属于自己的博客网站，写一写学习计算机过程中的一些技术总结、心得想法，找到了一个这个搭建比较简单，博客界面比较友好的Hexo，再此写下搭建的流程，避免之后采坑！</p>
<a id="more"></a>

<p>这里不在赘述如何进行Node和Git的配置安装，各种教程很多，我们直接进行Hexo的基本安装与部署。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="安装hexo-cli"><a href="#安装hexo-cli" class="headerlink" title="安装hexo-cli"></a>安装hexo-cli</h3><p>新建一个文件夹blog，安装<code>hexo-cli</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h3 id="安装hexo环境"><a href="#安装hexo环境" class="headerlink" title="安装hexo环境"></a>安装hexo环境</h3><p>安装<code>hexo</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure>

<p>运行后在当前文件下会生成如图：</p>
<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/hexo.jpg" alt="hexo npm" title="hexo安装"></p>
<p>在本机环境变量中配置hexo的<code>path</code>：</p>
<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/%E9%85%8D%E7%BD%AEpath.jpg" alt="path配置" title="path配置"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化Hexo博客：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/init.png" alt="初始化博客" title="init blog"></p>
<p>里面内容为：</p>
<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/mainblog.jpg" alt="主博客" title="main blog"></p>
<p><strong>至此，用Hexo搭建个人博客就完成了环境安装。我们试着运行一下</strong></p>
<h2 id="运行Hexo"><a href="#运行Hexo" class="headerlink" title="运行Hexo"></a>运行Hexo</h2><p>进入初始化完成的blog文件夹，我们称之为站点文件，然后运行git bash，然后开始部署：</p>
<h3 id="清理文件"><a href="#清理文件" class="headerlink" title="清理文件"></a>清理文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo cl   &#x2F;&#x2F;clean的缩写</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/clean.jpg" alt="清理" title="clean blog"></p>
<h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g   &#x2F;&#x2F;generate的缩写</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/generate.jpg" alt="生成" title="generate blog"></p>
<h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s   &#x2F;&#x2F;server的缩写</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/server.jpg" alt="运行" title="server blog"></p>
<p>在浏览器中输入<code>localhost:4000</code>即可看到运行起来的博客。</p>
<p><img src="/2020/01/12/Next%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2(%E4%B8%80)/local.jpg" alt="运行" title="local blog"></p>
<p><strong>好了，初始的Hexo安装完成了，接下来我们就可以选择自己喜欢的theme进行博客美化了！</strong></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>波卡白皮书Polkadot：畅想一种异构的多链架构</title>
    <url>/2020/01/08/Polkadot/</url>
    <content><![CDATA[<p>本文转载岳利鹏翻译的波卡白皮书 - Polkadot：畅想一种异构的多链架构。</p>
<a id="more"></a>

<p>波卡Polkadot：畅想一种异构的多链架构 <a href>原文Paper草案</a></p>
<p>作者：Gavin Wood 博士 以太坊&amp;Parity 创始人 <a href="mailto:GAVIN@PARITY.IO">GAVIN@PARITY.IO</a><br>译者：岳利鹏 <a href="mailto:lipeng@chainx.org">lipeng@chainx.org</a></p>
<p><strong>摘要</strong>：现有的区块链架构都存在诸多问题，不仅仅是从实用性角度所说的扩展性（extensibilty）和伸缩性（scalability）的问题。我们认为，问题源于把共识架构中两个很重要的部分：一致性（canonicality）和有效性（validity）绑定得太紧密了。这篇文章介绍了一种异构的多链架构，能从本质上把两者拆开。</p>
<p>为了分离这两者，且能保持最小化的绝对安全性（security）和传输性（transport）等基本功能，我们将介绍一种原生的支持内核可扩展（core extensibilty）的可行性方法。对于可伸缩性（scalability）的问题，我们通过对这两个问题分而治之的思路解决，通过非信任节点的激励机制，弱化他们的内生绑定关系。</p>
<p>本架构的异构本质，支持众多高度差异化的共识系统在非信任（trustless）、完全去中心化的联邦内交互操作，允许去信任（trust-free）地相互访问各区块链。</p>
<p>我们提出一种方式，支持向后兼容一个或多个现有的网络，比如以太坊等。我们相信这个系统能够提供一种有用的底层组件，能够实用性地支持全球商业级别的可伸缩性（scalability）和隐私性（privacy）。</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>这篇论文的意图只是一个技术版本的概要，旨在用一些原则来描述将要开发的这个区块链示例，解释这个可能方向的合理性。它罗列了诸多区块链技术方面的具体改善措施，以及在此开发阶段所能够提供的尽可能多的细节。</p>
<p>它并不是要写成一个形式化证明的说明书。它并不完整，也不是最终版本。它并不是为了覆盖框架非核心的模块，例如 API、依赖、语言和用法等。这只是概念性实验，都很可能会修改提到的参数。为了响应社区的意见和评论，会新增、重定义、删除各组件。通过实验性的证据和原型，给出关于什么会有效、什么不会的信息，也很可能修正本论文中大部分内容。</p>
<p>这篇论文包含了一个关于协议和一些想法的核心描述，可能会被用来解决多个方面的问题。它将是能够用来在概念验证阶段开展一系列工作的核心描述。一个最终的“1.0 版本”会基于这个协议，再添加一些变得可证明而且决定包含到项目中来的想法。</p>
<p>起草历史：</p>
<ul>
<li>2016 年 10 月 09 日：0.1.0-proof1</li>
<li>2016 年 10 月 20 日：0.1.0-proof2</li>
<li>2016 年 11 月 01 日：0.1.0-proof3</li>
<li>2016 年 11 月 10 日：0.1.0</li>
</ul>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><p>区块链已经承诺了它的伟大意义，能够应用于包括物联网（IOT）、金融、治理、身份管理、去中心化互联网和资产追踪等多个领域。然而抛开这些技术承诺和大话，我们还没有看到现有技术下，出现重大的关于现实世界的应用部署。我们相信这是因为现有技术的 5 个关键缺陷：</p>
<p><strong>伸缩性（Scalability）</strong>：全球范围内花费了多少计算、带宽和存储的资源，来处理单个交易？峰值情况下能处理多少交易？<br><strong>隔离性（Isolatability）</strong>：多参与方对于应用的差异化需求，能否在同一个框架下接近最优程度地满足？<br><strong>开发性（Developability）</strong>：工具的工作效果有多好？APIs 是否已满足开发者的需求？教程资料是否可用？是否集成权力？<br><strong>治理性（Governance）</strong>：网络是否保留了能够随着时间进化和适应的灵活性？制定决策能否高度地包容、合理和透明，来提供去中心化系统的高效领导力。<br><strong>应用性（Applicability）</strong>：技术是否真的解决了用户的刚性需求？是否需要其他的中间件来嫁接真实的应用？</p>
<p>当前的工作，我们主要面向前两个问题：伸缩性和隔离性。也就是说，我们相信 Polkadot 架构可以在这两个方面，提供有意义的改进。</p>
<p>当前，例如 Parity 以太坊客户端这样的高性能区块链实现，已经可以在消费级高速硬件上每秒处理超过 3000 笔的交易。然而现实世界的区块链网络却限制在 30 笔交易每秒的情况下。这种限制主要是源于目前同步（synchronous）的共识机制，需要充分的计算缓冲时间来安全地处理，也就加重了其必须对于慢速硬件的支持。这归咎于其底层的共识架构：状态转换机，或者这种让所有参与方校对和执行交易的方式，在本质上将其逻辑绑定在了共识一致性（canonicalisation）的设计上，或者需要让所有参与方都同意所有的可能性、有效性和历史。</p>
<p>这种说法即适用于类似比特币和以太坊这样的工作量证明（POW）系统，也适用于NXT 和比特股这样的权益证明（POS）系统，他们都本质上受制于同一个障碍，但这些共识算法却是个能让区块链成功的简单策略。然而，在一个协议里紧密捆绑这两个结构，我们也就捆绑了多个不同风险偏好、不同伸缩性需求、不同隐私需求的角色和应用。一种特征满足不了所有人的需求。因为这种场景，产生了很多次的广泛呼吁，但网络只能倾向于更保守，服务于少数人，最终导致在创新能力、性能和适应性方面的失败，非常戏剧化。</p>
<p>有一些系统例如公证通（Factom），整个地去除了状态转换机。然而大多数应用场景都需要依赖一个共享的状态机，来支持状态转换的功能。去除它只是隐藏了问题，却没有给出真正替代性的解决方案。</p>
<p>现在看起来清楚了，因此一个合理的方向是：像路由对于可伸缩去中心化计算平台那样，解耦共识组件和状态转换组件。而且不出意外的话，这也是 Polkadot 解决伸缩性问题的策略。</p>
<h3 id="2-1-协议、实现、网络"><a href="#2-1-协议、实现、网络" class="headerlink" title="2.1 协议、实现、网络"></a>2.1 协议、实现、网络</h3><p>和比特币、以太坊一样，Polkadot 希望一开始的时候只是个网络协议，并且是运行这一协议的主要公有网络（目前假设）。Polkadot 倾向于是个免费和开放的项目，协议在一个知识共享的许可证上制定，代码托管在 FLOSS 许可证下。这个项目以一种开放的状态开发，接收各方面有用的捐助。一个微意见提交系统（RFCs），但不像 Python 改进议程那样，会提供一种公众协作参与协议修改和升级的方式。</p>
<p>我们对 Polkadot 协议的初始实现，将称为 Parity Polkadot Platform，会包含协议的完整实现和 API 接口。像其他 Parity 的区块链实现一样，PPP 会设计成通用目的的区块链技术栈，并不限定于公有网络、私有网络或联盟网络。目前为止的开发已经被包括英国政府在内的几方资助。</p>
<p>但是，这篇论文还是在公有网络的场景下。我们在公有网络下预见的功能，是一个完整设想（比如私有或联盟网）的子集。另外在这个场景下，可以清晰地描述和讨论 Polkadot 的所有方面。这也是说读者需要知道，在非公有（有权限的）场景下，一些特定的机制（比如和其他公有网络的交互）并不直接和 Polkadot 相关。</p>
<h3 id="2-2-前人工作"><a href="#2-2-前人工作" class="headerlink" title="2.2  前人工作"></a>2.2  前人工作</h3><p>从状态转换中解耦底层的共识，已经私下讨论了两年，在以太坊的最早期的时候 Max Kaye 就提议过。</p>
<p>一个更复杂的可伸缩方案叫做 <strong>Chain fibers</strong>，这要回溯到 2014 年 6 月，在那年底也发表了。它创造了一个关于单个中继链（relay-chain）和多个同构链，可以透明地跨链执行的先例。退相干性（Decoherence）通过交易延迟（latency）来实现，这就使需要更长时间，来处理需要协调系统多个部分的交易。Polkadot 借鉴了很多它的架构以及随后跟很多人的讨论，虽然跟它的设计和规定也很不一样。</p>
<p>然而目前并没有运行在生产环境下的系统可以和 Polkadot 相比，有的也只是提出了些相关性功能，很少有本质层面的细节。这些提议可以归纳为：丢弃或减少状态机全局相关性的系统、试图通过同构分片提供全局相关性的单例状态机系统、目标仅是异构性（heterogeneity）的系统。</p>
<h4 id="2-2-1-没有全局状态的系统"><a href="#2-2-1-没有全局状态的系统" class="headerlink" title="2.2.1 没有全局状态的系统"></a>2.2.1 没有全局状态的系统</h4><p>公证通（Factom）演示了个没有有效性的一致性系统，能够高效地记载数据。由于没有全局状态和其带来扩展性问题，它可以被看做是一个可伸缩的方案。然而前面也提到了，严格上来说它只解决了很少的问题。</p>
<p>Tangle 是个关于共识系统的概念性尝试。不把交易排序再打包到区块中，而是通过串联的共识得出一个全局的一致性状态改变排序，它在很大程度上抛弃了高度结构化的排序想法，而是推出一个有向无环图，后续的有依赖的交易通过明确的指向，来帮助前面的交易达成一致。对于任意的状态改变，这个依赖图就会很快地变得无法处理，然而对于更简单的 UTXO 模型，立即就变得合理了。因为系统总是松散地连贯，而且交易通常是相互独立的，大规模的全局并发变得非常自然。使用 UTXO 模型确实可以让 Tangle 定位成价值转移的货币系统，而并没有其他的更多通用和可扩展的功能。因为没有了全局依赖性，而和其他系统的交互又需要确定性地知道其状态，这种方法就变得不切实际了。</p>
<h4 id="2-2-2-异构链系统"><a href="#2-2-2-异构链系统" class="headerlink" title="2.2.2 异构链系统"></a>2.2.2 异构链系统</h4><p>侧链是个支持比特币主链和附属链之间去信任交互的提案。但并没有任何和侧链进行富（rich）交互的具体规定：交互被限定在允许和侧链之间相互托管对方的资产，也就是行话所说的双向锚定（two-way peg）。最终也是为了做个框架，通过锚定比特币链和其他链，允许在比特币协议之外进行外部交易，为比特币添加附属的外围功能。从这方面讲，侧链系统更多着眼于可扩展性而不是可伸缩性。</p>
<p>根本上讲，侧链确实没有关于有效性的条款，从一条链（比如比特币）的代币转到另一条链上，安全性只是寄希望于侧链能否激励矿工来一致性地验证交易。比特币网络的安全性无法简单地在其他链上起作用。进而一个确保比特币矿工联合挖矿（复制他们的一致性算力到侧链上），并且同时验证侧链交易的协议也被提出来了。</p>
<p>Cosmos是个延续侧链思路提出来的多链系统，替换中本聪的 PoW 共识算法为 Jae Know 的 Tendermint 共识算法。本质上，它包含多个使用独立 Tendermint 实例的区块链（在空间 zone 中运行），和一个使用去信任通信的中心（hub）链。跨链通信仅限于转移数字资产（也就是代币），而不是任意信息，然而这种跨链通信是可以返回数据和路径的，比如给发送人通知转账的状态。</p>
<p>和侧链一样，空间链上验证人的经济激励问题也没有解决。一般的假设是每个空间链会各自持有通胀增发的支付代币。设计仍然还比较早期，现阶段的也缺乏在全局有效性上建立可伸缩一致性的经济手段细节。然而相比于那些需要强耦合的系统，为了空间链和中心链间的松耦合性，需要给空间链的参数添加更多灵活性。</p>
<h4 id="2-2-3-Casper"><a href="#2-2-3-Casper" class="headerlink" title="2.2.3 Casper"></a>2.2.3 Casper</h4><p>目前关于 Casper 和 Polkadot 之间，还没有完整的讨论和比较，即使是公平和彻底（也不准确）地描述两者。Casper 是正在重塑 PoS 的共识算法，它研究如何让参与方在最终会确定的分叉上押注。本质上，需要考虑即使是长程攻击的情况下，也要保证应对网络分叉的健壮性，还需考虑基础以太坊模型上的可伸缩性。因此，在本质上 Casper 协议的目标比 Polkadot 和以往项目要复杂的多，也偏离了基础的区块链模型。它仍然还没有做出来，不知道将来如何运作，也不知道最终会开发出来的样子。</p>
<p>然而 Casper 和 Polkadot 都代表了有趣的新一代协议，对于以太坊的争论，本质上也是他们的终极目标和实现路径上的差异。Casper 是以太坊基金会主导的一个项目，只是被设计用来作为 PoS 协议的替代，没有从本质上打造可伸缩区块链的意愿。关键还需要一次硬分叉来升级，而不能时可扩展的，因此所有的以太坊客户端和用户都需要升级，否则就得留在原来的前途不明朗的分叉上。因此，这类协议在去中心化系统上的部署会很困难，需要紧密的协调。</p>
<p>Polkadot 在几方面上不同；首先而且也是最重要的，Polkadot 将被设计成完全可扩展和可伸缩的区块链开发、部署和交互测试平台。他将被设计为面向未来的、可以吸收最新的可用区块链技术的平台，且不需要过于复杂的去中心化协调和硬分叉。我们已经预见到了几个应用场景，例如高度加密的联盟链和低区块时间的高频链等，它们不太可能在近期的以太坊上实现。它们最终和以太坊之间的耦合度也会很低，以太坊上也没有支持两者间非信任交互的想法</p>
<p>简言之，尽管 Casper/以太坊 2.0 和 Polkadot 有一些相似点，我们相信从本质上它们最终的目标是不一样的，并非竞争，在可预见的将来，两个协议会大概率地并存。</p>
<h2 id="3-概要"><a href="#3-概要" class="headerlink" title="3.概要"></a>3.概要</h2><p><strong>Polkadot 是一个可伸缩的异构多链系统</strong>。这意味着不像以往那些专注于不同程度潜在应用功能的单个区块链实现，Polkadot 本身被设计成不提供任何内在的功能应用。</p>
<p>Polkadot 提供了中继链（relay-chain），在其上可以存在大量的可验证的、全局依赖的动态数据结构。我们称这些平行的结构化的区块链为平行链（parachains），尽管也不要求它们必须是一条链。</p>
<p>换句话说，<strong>Polkadot 会被设计成一个独立链的集合</strong>（例如包含以太坊、以太坊经典、域名币、比特币），除了两个非常重要的点：</p>
<ul>
<li>合并的安全性</li>
<li>去信任的跨链交易性</li>
</ul>
<p>这两点也是我们称 Polkadot 为可伸缩的原因。从原则上，一个问题在 Polkadot 上被彻底解决了：可以向外扩展，会有非常大数量的平行链。尽管每条平行链在各方面都通过不同的网络模式进行平行管理，但这个系统却有可伸缩的能力。</p>
<p>Polkadot 提供了一个尽量简单的架构，把大部分的复杂性都放在了中间件上。这是个刻意的决定，为了试图减少开发的风险，使必备的软件可以在短时间内开发出来，还能对安全性和健壮性持有信心。</p>
<h3 id="3-1-Polkadot的哲学"><a href="#3-1-Polkadot的哲学" class="headerlink" title="3.1 Polkadot的哲学"></a>3.1 Polkadot的哲学</h3><p>Polkadot 需要提供一个绝对坚实的基座，来在其之上建设下一代共识系统，覆盖从生产级别的成熟设计到初期想法的所有风险。通过对安全性、隔离性、通信能力提供强有力的保证Polkadot 能够允许平行链从一系列特性中选择适合它们自己的。的确，我们预见了各种实验性的经过考虑的区块链特性。</p>
<p>我们看到，传统的高市值区块链（例如比特币和 Zcash）、低市值的概念性区块链和接近零手续费的测试网，是并存在一起的。<br>我们看到，全加密的暗黑联盟链和高功能性的开放区块链（例如以太坊）也并存在一起，甚至还为之提供服务。<br>我们看到，实验性的新虚拟机区块链，比如主观时间计费的 Wasm 区块链，在将难度计算问题从类似以太坊的区块链方式，修改成类似比特币的区块链方式</p>
<p>为了管理区块链升级，Polkadot 将内生支持某种形式的治理结构，很可能基于现有的稳定政治体系，会有一个两院结构，类似于 Yellow Paper Council。底层权益代币持有者作为最高权力机构，会有全民投票控制权。为了反映用户的需求、开发人员的需求，我们期望建立一个合理的两院结构，采纳用户的意见（由绑定的验证人决定）、主要客户端开发者和生态系统玩家的意见。代币持有者会保留最高的合法权，可以形成一个最高法庭来参政、议政、替换或解散这个架构，还有那些我们不怀疑的最终需求。</p>
<p>借用一句马克吐温的谚语：“政府和尿布都得经常换，而且理由都一样”。</p>
<p>然而在大范围共识的机制下组织参政会很琐碎，更多关于替换和新增的质的改变，希望既不是通过非自动的弱法令（例如通过块高度和新协议的形式化证明文档的哈希）来达到一致性，也不是通过在核心共识算法中包含一个高效的高级语言，来改变他自身可能需要改变的各个方面。后者是一个最终目标，然而为了落实一个合理的开发路线图，更可能选择前者。</p>
<p>Polkadot 看重的主要原理和规则有：</p>
<p><strong>最小</strong>：Polkadot 需要有尽可能少的功能性。<br><strong>简单</strong>：只要他们可以推给中间件、放在平行链、或用下面要讲的一种优化手段，就不在基础协议里添加多余的复杂性。<br><strong>通用</strong>：没必要在平行链中添加任何要求、约束或限制；Polkadot 需要成为共识系统开发的基石，要尽量通过给模型加入最具适应度的扩展和优化。<br><strong>健壮</strong>：Polkadot 需要提供一个稳定的基础层。为了经济稳定性，需要采用分散的方法，来降低高额奖励这个攻击向量可能引发的问题。</p>
<h2 id="4-Polkadot的参与方"><a href="#4-Polkadot的参与方" class="headerlink" title="4.Polkadot的参与方"></a>4.Polkadot的参与方</h2><p>有四个基本的角色在维持 Polkadot 网络：收集人（collator）、渔夫（fisherman）、提名人（nominator）、验证人（validator）。在 Polkadot 的一个可能实现里，最后一个角色有可能会被拆分成两个：基础验证人和可用保证人（guarantor），将会在 6.5.3 节讨论。</p>
<p><img src="/2020/01/08/Polkadot/Polkadotfig1.jpg" alt="图1：Polkadot 四个角色的交互" title="图1：Polkadot 四个角色的交互"></p>
<p>​                                                        图 1. Polkadot 四个角色的交互</p>
<h3 id="4-1-验证人"><a href="#4-1-验证人" class="headerlink" title="4.1 验证人"></a>4.1 验证人</h3><p>验证人有最高权限，帮助在 Polkadot 网络里打包新区块。验证人需要抵押足够多的押金，因为我们允许其他有资金的提名人推举一个或多个可以代表他们的验证人，所以验证人一部分的押金并不是他们自己所拥有的，而是属于提名人的。</p>
<p>一个验证人必须在高可用和高带宽的机器上运行一个中继链的客户端。每个区块上，节点都必须准备接收一个已提交的平行链上的新区块。这个过程涉及接受、验证、再发布候选区块。验证人的任命是确定性的，但实际上也很难预测。因为不能期望验证人拥有所有平行链的全同步数据，所以他们希望把这个提议平行链新区块的工作指派给第三方，也就是收集人。</p>
<p>不同的验证人小组一旦都确定性地批准了自己所属平行链的新块，他们就必须开始批准中继链自身的区块。这包括更新交易队列的状态（也就是从一条平行链的出口队列转移到另一条平行链的入队列）、处理已批准的中继链的交易集合、批准最终的区块、吸收平行链的最终改变。</p>
<p>在我们选择的共识算法下，会惩罚一个没有履行他们职责的验证人。最开始如果不是有意的错误，就只是会扣留他们的奖励，但如果是重复的错误会扣减他们的押金（通过烧毁），例如双向签名（double-signing）或合谋提供一个非法区块等可证明的恶意行为，会导致他们丧失全部的押金（烧毁一小部分，大部分奖励给信息提供方和诚实的验证人）。</p>
<p>在某种程度上，验证人和目前 PoW 区块链的矿池相似。</p>
<h3 id="4-2-提名人"><a href="#4-2-提名人" class="headerlink" title="4.2 提名人"></a>4.2 提名人</h3><p>提名人是一个拥有权益的群体，他们把安全性押金委托给验证人。他们没有更多的角色，除了通过有风险地投放资本来表示：他们信任某个特定的验证人（或群体）可以代表他们维护整个网络。按照他们的入金比例，他们也会受到和验证人总押金同样比例的奖励和扣减。</p>
<p>和下面的收集人一样，提名人和目前 PoW 网络的矿工相似。</p>
<h3 id="4-3-收集人"><a href="#4-3-收集人" class="headerlink" title="4.3 收集人"></a>4.3 收集人</h3><p>交易收集人是帮助验证人制造有效的平行链区块的群体。他们会运行一个特定平行链的全节点，这也意味着他们有全部的必要信息，可以打包新块并执行交易，就跟目前 PoW 区块链的矿工一样。在正常情况下，他们会收集并执行交易，并创建一个”未密封”（unsealed）的区块，再加上一个零知识证明一起提交给一个或多个当前负责提议（proposing）该平行链区块的验证人。</p>
<p>关于收集人、提名人、验证人的精确关系可能还会修改。起初，我们希望收集人和验证人能够紧密合作，因为可能只有一些（甚至一个）交易量很小的平行链。最初的客户端实现会包含一个 RPC 接口，来支持一条平行链的收集人节点把可证明的有效平行链区块，无条件地提供给一个（中继链）验证人节点。由于维持所有的全同步平行链的成本越来越高，所以我们设计了附加的结构，有助于分离独立的、经济驱动的、和其他的参与者。</p>
<p>最终，我们希望看到收集人群体为了更多手续费，竞争性地去收集信息。在一段时间内，为了持续增长的份额收益奖励，这些收集人可能只服务于特定的验证人群体。或者自由职业（freelance）的收集人也可以简单地创建一个市场，提供有效的平行链区块，而不是获得立即支付的竞争性份额奖励。同样地，去中心化的提名人群体也会允许多个有抵押的参与者来协调和分担验证人的职责。这种能力保证了参与的开放度，有助于成为更加去中心化的系统。</p>
<h3 id="4-4-渔夫"><a href="#4-4-渔夫" class="headerlink" title="4.4 渔夫"></a>4.4 渔夫</h3><p>不像其他的两个参与方，渔夫并不直接和区块打包的过程相关。他们是独立的“赏金猎人“，激励他们的是一次性的大额奖励。</p>
<p>准确地说，由于渔夫的存在，我们才能减少恶意行为的发生，即使发生希望也只是因为私钥不小心泄露了，而不是故意的恶意企图。起这个名字的出发点是考虑到他们期望收益的频率和最终奖励的大小。</p>
<p>渔夫只要及时举报并证明至少一个有抵押的参与方存在非法行为，他们就能获得奖励。非法行为包括对两个有相同父块的不同区块进行签名，或在平行链上批准一个无效区块。为了预防由于私钥泄露给渔夫所导致的过渡奖励，渔夫上报关于单个验证人的非法消息签名的基础奖励是从最小开始的，这个奖励会随着其他渔夫上报更多的非法签名而逐渐增加。依据我们基本的安全性假设：至少三分之二的验证人是诚实的，渐近线将设置在 66%。</p>
<p>渔夫某种程度上和目前区块链系统的全节点相似，他们所需要的资源相对较少，也没必要承诺稳定的在线时间和大的带宽。渔夫有如此大的不同，所以他们只需要提交很少的押金。这个押金用于预防浪费验证人计算时间和计算资源的女巫攻击。它是立即可以提现的，很可能不会比等值的几个美金更多，但如果监测到一个不当行为的验证人，可能会收获很大的奖励。</p>
<h2 id="5-设计综述"><a href="#5-设计综述" class="headerlink" title="5.设计综述"></a>5.设计综述</h2><p>本章试图给出一个系统的全局完整描述。对系统更加深入的解释会在接下来的一章中给出。</p>
<h3 id="5-1-共识"><a href="#5-1-共识" class="headerlink" title="5.1 共识"></a>5.1 共识</h3><p>在中继链上，Polkadot 通过一个现代的异步（asynchronous）拜占庭容错（BFT）算法达成对有效区块的相互共识。算法受简单的 Tendermint 和 HoneyBadgerBFT 启发。后者在有任意网络缺陷的架构下，只要满大部分验证人是诚实的，就能提供了一种高效的容错算法。</p>
<p>也许一个权限证明（PoA）模式的网络就足够了，然而 Polkadot 是个可以在全开放和公开的场景下部署的网络，不需要信任任何特殊的组织和当权者来维护它，因此我们需要一种管理验证人群体并且激励他们守法的方法。我们选择使用以 PoS 为基础的共识算法。</p>
<p><img src="/2020/01/08/Polkadot/Polkadotfig2.jpg" alt="图2：Polkadot 的概括性原理图" title="图2：Polkadot 的概括性原理图"></p>
<p>​                                                              图 2：Polkadot 的概括性原理图</p>
<p>图 2展示了收集人收集并且广播用户的交易，也广播候选区块给渔夫和验证人。展示了用户提交一个交易，先转移到平行链外部，然后通过中继链再转移到另一条平行链，成为一个可以被那里的账户执行的交易。</p>
<h3 id="5-2-权益证明"><a href="#5-2-权益证明" class="headerlink" title="5.2 权益证明"></a>5.2 权益证明</h3><p>我们假设网络可以度量每个账户有多少权益（stake）。为了更轻松地和现有系统对比，我们把度量单位称为 “代币（tokens）”。不幸的是由于它仅仅能作为对账户简单的价值度量，也没有任何个性化，因此多种原因使这个术语并不那么理想化。</p>
<p>通过一个被提名的权益证明（Nominated Proof-of-Stake NPos）结构，我们猜想验证人的选举不会很频繁（很可能是一个季度一次，最多一天一次）。通过按比例分配的增发出来的代币（很可能大约 10%，最多每年 100%）和收集到的交易手续费来进行激励。虽然货币增发一般都会造成通胀，但因为所有代币持有者都有公平参与的机会，所以代币持有者的资产不会随着时间而遭受损失，他们会很开心地参与到该共识机制中来。全网权益证明的开展所需的抵押必须达到一个特定的最小比例。会根据市场机制，达到有效的代币增发这个目标。</p>
<p>验证人严重依赖他们抵押进来的权益。现存验证人的押金会从他们离职的时候开始，要再保留更长时间（也许 3 个月左右）。这么长的押金冻结期是为了还能惩罚将来的不当行为，直到区块链周期性的检查点到来。不当行为会遭到例如减少奖励等的惩罚，如果是故意破坏网络的完整性，验证人将会损失部分或全部的权益，转移给其他验证人、信息提供者或全部权益持有者（通过烧毁）。例如一个验证人试图同时批准不同分叉上的两个分支（有时也被称为短程攻击），就会被后面的方法鉴别并遭到惩罚。</p>
<p>检查点锁定器（checkpoint latch）能规避长程“无权益抵押”（nothing-at-stake）攻击，防止比一般长度更长的高度危险的链重构（chain-reorganistation）发生。为了保证最新开始同步的客户端不会被误导进错误的链，网络会出现定期的“硬分叉”（最长也就是验证人的押金冻结期），把最近检查点区块的哈希值硬编码（hard-code）进客户端。将来通过逐步递减有限链的长度（finite chain length），或周期性地重置创世块（genesis-block），这种方法会运行得很好。</p>
<h3 id="5-3-平行链和收集人"><a href="#5-3-平行链和收集人" class="headerlink" title="5.3 平行链和收集人"></a>5.3 平行链和收集人</h3><p>每条平行链将给中继链提供同样的安全性保证：平行链的区块头会被包含进中继链的区块中，还跟着一些确认信息，用来保证不会发生链重构或双重花费（double-spending）。类似于比特币侧链和联合挖矿的安全性保证，Polkadot 也强力保证平行链状态交易的有效性。会依据密码学算法，把验证人随机地分成很多个组。一条平行链对应一组，甚至每个块的组也都可能不一样。这个设置意味着中继链至少也要和平行链的出块时间一样短。本文不讨论分组的特定决定方式，可能要么是围绕类似 RanDAO 的提交-披露（commit-reveal）框架，要么结合平行链前一个区块的密码学哈希值。</p>
<p>这样的验证人组需要提供平行链的候选块，还要保证它们是有效的（否则损失押金）。有效性围绕两个重要的点：第一，它是内生有效的，所有的状态转换被公正地执行，包括引用的外部数据也被公正执行（比如交易）。第二，参与方需要可以简便地访问候选块的任何外部数据，例如外部交易等，然后就可以下载这些数据并手工执行候选块。验证人可以提交没有包含任何外部交易数据的空块（null），如果他们这样做，就要承受奖励减少的风险。他们和收集人在平行链的一个 gossip 协议上工作，收集人把交易收集到块里，并且要提供一个非交互的零知识证明（noninteractive zero-knowledge），用来证明本子块的父块是有效的（为该工作收取任何手续费）。</p>
<p>防止垃圾（spam）数据的方法留给了平行链协议自身：中继链本质上不规定“计算资源计量” 和 “交易费” 。本质上也不强制平行链规定相关协议（尽管权益持有者不太可能愿意接纳一个没有提供合理机制的平行链）。这里明确地说明了并不会都像以太坊的手续费规则，也可以类似比特币的区块链手续费模型，或其他任何还没有提出来的垃圾预防模型。</p>
<p>Polkadot 的中继链本身将很可能存在一个类似以太坊的账户和状态模型，可能是 EVM 的衍生版本。因为中继链节点将需要做大量的其他计算，将会通过提高手续费尽量减小交易吞吐量，我们的模型还会包含块大小的限制。</p>
<h3 id="5-4-跨链通信"><a href="#5-4-跨链通信" class="headerlink" title="5.4 跨链通信"></a>5.4 跨链通信</h3><p>Polkadot 最关键的部分是跨链通信。因为在平行链间可以存在某种信息通道，我们才说 Polkadot 是可伸缩的多链系统。在 Polkadot 中，通信可以很简单：一条平行链中的执行交易的时候（依据那条链的逻辑），可以给第二条平行链或中继链转发一个交易。目前生产环境中的区块链外部交易，都只能是完全异步的，他们并没有给它的来源方返回任何信息的原生能力。</p>
<p><img src="/2020/01/08/Polkadot/Polkadotfig3.jpg" alt="图3：一个基本的原理图，展示了路由已提交的交易（“提交”）的主要逻辑" title="图 3：一个基本的原理图，展示了路由已提交的交易（“提交”）的主要逻辑"></p>
<p>​                            图 3：一个基本的原理图，展示了路由已提交的交易（“提交”）的主要逻辑</p>
<p>为了保证最小的实现复杂度、最小的风险和最小的平行链架构束缚，这些跨链交易和目前标准的外部交易没有区别。这些交易会有个来源方字段，用来辨别平行链的身份，还有个可以是任意长度的地址。跨链交易需支付的手续费，并不像目前的比特币或以太坊系统那样，而是必须通过来源平行链和目的平行链的谈判逻辑来管理。一个在以太坊的Serenity 版本中提出的改进提案，会是一个简单管理这种跨链资源支付的方法，尽管我们假设其他人会提出更先进的方法。</p>
<p>跨链交易的问题可以用一个简单的队列机制解决，这个队列用梅克尔树（Merkle tree）来保证数据真实。中继链的任务是把交易从来源平行链的出口队列转移到目的平行链的入队列。已转发的交易会在中继链上被引用，而不是中继链自身的交易。为了预防一条平行链往另一条平行链发送垃圾交易，规定在在前一个块结束后，发送每一个交易时，目标平行链的入队列不能太大。如果区块处理完后，入队列太大，那么目的平行链会被看做是饱和了，接下来的几个块里就不会再路由交易给它，直到入队列降到临界值以下。这些队列在中继链上管理，允许各平行链相互决定他们的饱和度大小。如果再往停滞的目标链发送交易，这样就可以同步地报告失败了（因为不存在返回路径，如果第二个交易也是同样的原因失败了，它可能也不会给来源调用者发送回复，这就需要用到一些其他的恢复方法）。</p>
<h3 id="5-5-Polkadot-和以太坊"><a href="#5-5-Polkadot-和以太坊" class="headerlink" title="5.5 Polkadot 和以太坊"></a>5.5 Polkadot 和以太坊</h3><p>归功于以太坊的图灵完备特性，至少在简单的可论证的安全性边界内，我们期望 Polkadot 和以太坊有丰富的交互可能性。简而言之，我们预想到了，从 Polkadot 出来的交易，可以让验证人先签名，然后再喂给以太坊，在那里通过一个交易转发（transaction-forwarding）合约来解释和执行。反方向，我们也预想到了，从以太坊上的一个 “外向合约”（break-out contract）中的特殊格式日志，可以快速地证明一个消息是否真的要被转发。</p>
<h4 id="5-5-1-从-Polkadot-到以太坊"><a href="#5-5-1-从-Polkadot-到以太坊" class="headerlink" title="5.5.1 从 Polkadot 到以太坊"></a>5.5.1 从 Polkadot 到以太坊</h4><p>通过选择一个拜占庭容错算法，验证人经由授权投票产生的一系列权益持有者组成，我们能够获得一个安全的共识机制，用不经常更改的合适数量的验证人。在一个总共有 144 个验证人的系统内，4s 出块时间和 900 个块的最终性（允许举报、惩罚、修复类似双向投票的恶意行为），一个区块的有效性可以合理地考虑为用最少 97 个签名证明（144的三分之二再加一）,然后跟着的是 60 分钟无风险注入的验证时间。</p>
<p>以太坊可以包含一个控制和维护 144 个签名的“内向合约”（break-in contract），由于椭圆曲线数字签名的验签操作只要花费 EVM 3000 gas的计算量，而且因为我们只希望验证操作发生在大多数的验证人里（而不是全体），以太坊确认一个从 Polkadot 来的指令的基础花费不会超过 300,000 gas——仅仅是区块 550 万 gas 限制的 6%。增加验证人的数量（只有在处理数十个区块链的时候才必要）不可避免地会增加成本，然而很明显可以期望到随着以太坊技术的成熟和架构的改进，交易吞吐量会随着时间而增加。另一个事实是不是所有的验证人都会参与（例如只有最高押金的验证人才会做这个任务）这种结构的限制会比较合理。</p>
<p>假设这些验证人每天轮换（更保守的、更可能接收的是每周，甚至每月），网络给维持这个以太坊转接桥的成本大约是 540,000 gas 每天，或者按照当前的 gas 价格，45 美金一年。一个通过转接桥的基本转发交易会花费大约0.11美金；当然另外的合约计算会耗费更多。通过缓存和捆绑多个交易，内向的交易花费可以简单地分担，减少每个交易的花费。如果一次转发需要凑够 20 个交易，那么转发一笔基本交易的花费会降低到大约0.01金。</p>
<p>在这个模型中，Polkadot 的验证人节点除了签名消息之外只需要再做很少的事情。为了能够把交易路由到以太坊网络里，我们假设任何一个验证人需要属于以太坊网络，更可能的只需提供很少的奖励给第一个在网络上转发消息的人（奖励会支付给交易发起人）。</p>
<h4 id="5-5-2-从以太坊到-Polkadot"><a href="#5-5-2-从以太坊到-Polkadot" class="headerlink" title="5.5.2 从以太坊到 Polkadot"></a>5.5.2 从以太坊到 Polkadot</h4><p>使用一个叫做日志的概念，把交易从以太坊上转发到 Polkadot 上。当一个以太坊合约希望派生出一个交易给 Polkadot 上面的某一条平行链，它只需简单地调用一个特殊的“外向合约” 就好。那个外向合约会索取任何必须的费用，然后生成一个日志打印指令，以便于通过梅克尔树和有块头哈希来证明它的存在。</p>
<p>在下面的两个情况中，可以非常简单地证明有效性。原则上，唯一的要求是每个 Polkadot 节点都要运行一个全同步的标准以太坊节点。然而这本身就是非常重的依赖。一个更轻量的方法是提供一个简单的证明，仅需要包含正确执行该交易所必须知晓的以太坊的那部分状态树，然后再检查日志的有效性。这种类似简单支付验证（SPV-like）的证明不需要提供大量的信息。更方便的是，验证人可能完全不需要自己运行节点，Polkadot 内的押金系统能支持第三方参与者来提交块头，因为其他第三方（也就是所说的渔夫）也可能提供一个他们块头是无效的证明（具体地说就是状态根和回执根是错误的），所以这些人也冒着损失他们押金的风险。</p>
<p>在一个类似以太坊这样的无最终确定性（non-finalising）的 PoW 网络上，不可能存在最终可证明的一致性。为了适应这个，程序需要依赖一定的块确认数量，或者直到那个依赖的交易已经在链内某一特定深度了。在以太坊上，这个深度从最脆弱的 1 个块（网络都还不完全知道）延伸至 1200 个块（从 Frontier 上线到以太可交易）。在 Homestead的稳定版本上，大部分交易所选择了 120 个块这个数字，我们也可能会选择相近的参数。所以我们可以想象 Polkadot 这边的以太坊接口有一些简单的功能：可以接受以太坊网络的新块头，并能验证它的 PoW，可以结合一个有足够深度的块头（还有 Polkadot 内转发的相应信息），来验证从以太坊那边的外向合约打印出来的特定日志的证明，还可以接收关于之前收到的但还没有确定的块头里包含无效的回执根的证明。</p>
<p>需要有一个转发激励机制，才能够真正地在 Polkadot 网络里得到以太坊块头的数据（还有任何关于有效性和一致性的 SPV 证明）。这可能设计成只是个简单的支付行为（由在以太坊那边收集的手续费资助），转给任何能够提供一个有效块头的人。为了能够应对分叉，验证人需要保留最近几千个块的信息，要么由协议原生支持，要么通过中继链上的合约。</p>
<h4 id="5-5-3-Polkadot-和比特币"><a href="#5-5-3-Polkadot-和比特币" class="headerlink" title="5.5.3 Polkadot 和比特币"></a>5.5.3 Polkadot 和比特币</h4><p>Polkadot 和比特币的交互是非常有挑战性的：从两边的网络角度考虑，一个所谓的“双向锚定” 架构会非常有用。然而由于比特币的局限性，如何提供一种安全性的锚定个是非常艰难的任务。可以使用类似以太坊的流程，从比特币转发一个交易到 Polkadot：由一个受 Polkadot 验证人控制的“外向地址”（break-out address）来托管转账过来的代币（和附属的数据）。可以通过结合一个确认期，来激励先知（oracles）提供 SPV 证明，先知们通过标识一个非一致性的区块，来证明一笔交易存在双花的可能。任何在外向地址里托管的比特币原则上也被相同的验证人群体控制。</p>
<p>问题是如何保证这些比特币，是被轮换的验证人集合所控制的。相比于以太坊那样可以根据在合约内任意组合签名规则的方法，比特币的局限性就更多了，大部分的比特币客户端只接受最多 3 方的多重签名。扩充至 36 个或者大家希望的最高至上千个的终极提议，在现有的比特币协议里还不可能实现。一个选择是修改比特币的协议来支持这个功能，然而硬分叉在比特币的世界里非常难以安排和讨论。另一个可能性是使用门限（threshold）签名的方法，用密码学的结构来构造一个被被多个私钥片段共同控制的公钥地址，要制造一个有效的签名需要这些人的大部分或全部人都参与。不幸的是，和比特币的 ECDSA 相比，门限签名计算起来非常耗资源，而且是多项式级别的复杂度（polynomial complexity）。</p>
<p>由于入金的安全根本性由有抵押的验证人决定，所以另一个选择是减少多重签名的私钥持有人数量至只有重度质押的验证人才能参与，这样门限签名就变得可行了（或者最糟糕的情况，也可能直接用比特币的原生多重签名）。由于要预防验证人的非法行为，这个方法会降低可托管的比特币总量。然而这是一个优雅的妥协，可以简单地设置能够安全地在两个网络里的转移的基金总额上限（验证人攻击失败可能会受到的押金损失，和攻击成功可能的会收到的比特币潜在收益对比）。</p>
<p>因此，我们认为在现有的比特币框架下，开发出一个能够在两个网络间安全转移比特币的平行链是不现实的，尽管如此，比特币的持有者还可以在不确定的将来协调这些工作。</p>
<h2 id="6-协议细节"><a href="#6-协议细节" class="headerlink" title="6.协议细节"></a>6.协议细节</h2><p>本协议可以大致分为三个部分：共识机制、平行链接口、跨链交易路由系统。</p>
<h3 id="6-1-中继链操作"><a href="#6-1-中继链操作" class="headerlink" title="6.1 中继链操作"></a>6.1 中继链操作</h3><p>中继链会类似以太坊，也是基于状态的，包含一个账户信息到状态存储的映射关系，其中信息主要包含余额和交易计数器（防止重放）。把账户系统放在这里的目标是：记录每个身份在系统里控制了多少权益。但还有一些值得注意的差异：</p>
<ul>
<li>不能通过交易部署合约；这是为了让中继链尽量缺乏功能性，不支持公开部署合约。</li>
<li>没有资源计数器（gas）；因为公众能够调用的一些功能是固定的，gas 记录系统的原理就不适用了。因此在所有功能中，会使用一个更通用的手续费标准，这样就能更高效地执行那些动态代码，交易格式也会更简单。</li>
<li>会有一些包含特殊功能的默认合约，他们管理交易的自动执行和网络消息的输出。</li>
</ul>
<p>中继链会有一个基于 EVM 的虚拟机，但为了最大程度地简化会做很多修改。它会有一些内置合约（类似于地址在 1-4 之间的那些以太坊合约）运行平台的特定功能，包括共识合约、验证人合约、平行链合约。</p>
<p>如果不用 EVM，很有可能会选择 Web-Assembly（Wasm）；这样的话，所有结构还是相似的，但是这些基于 Wasm 的内置合约使用的是通用功能的语言，而不再是 EVM 上面的那些带有很多限制的不成熟语言。</p>
<p>还可能借鉴目前以太坊上衍生出来的其他方面的概念，例如在 Serenity 版本中提出来一些改变，比如为了能在一个块里并行执行那些没有状态冲突的交易，将交易的回执格式简化等。</p>
<p>Polkadot 有可能会部署一个类似于 Serenity 的纯净（pure）区块链系统，它不包含链的任何基础协议。但我们觉得这会带来更多的复杂性和开发不确定性，所以不太值得在目前阶段就去实现这么一个更高效且简洁的伟大协议。</p>
<p>为了管理共识机制，需要很多小片儿的功能：验证人集合、验证人机制、平行链等。这些都可以放在一个整体的协议中。然而为了实现模块化，我们会把这些描述成中继链的合约。这意味着他们都是中继链共识机制管理的对象（类似面向对象语言），但不一定是类似 EVM 的字节码，也不一定能通过账户系统寻址。</p>
<h3 id="6-2-权益合约"><a href="#6-2-权益合约" class="headerlink" title="6.2 权益合约"></a>6.2 权益合约</h3><p>这个合约管理着验证人集合：</p>
<ul>
<li>哪些账户是验证人；</li>
<li>哪些在短期内可以变成验证人；</li>
<li>哪些账户为了提名验证人而质押了权益</li>
<li>每个人的属性，包括余额、可接受的押金比例、地址列表、会话（session）身份</li>
</ul>
<p>它让账户在想成为验证人的时候可以来注册（需满足某些要求）、也可以提名某用户、在想退出验证人角色的时候还可以来退出。它自身还包含了一些用于验证和达成一致性的功能。</p>
<h4 id="6-2-1-权益代币的流动性"><a href="#6-2-1-权益代币的流动性" class="headerlink" title="6.2.1 权益代币的流动性"></a>6.2.1 权益代币的流动性</h4><p>通常我们希望能从网络中把尽可能多的权益代币都抵押进来，因为这关系到抵押权益的总市值和网络的安全性。这可以很简单地通过货币增发和收益分发来激励验证人。然而，这么做会出现一个问题：如果代币都被抵押在权益合约里，用于防止作恶，那么如何保证代币在一定程度上的基本流动性，进而支持价格发现呢？</p>
<p>一种方法是提供一个前向衍生合约来管理由抵押代币衍生出来的二级代币。但这在非信任的情况下很难实现。这些衍生代币无法等值交易，原因就和欧元区的不同政府发行的债券一样：抵押的代币有可能被扣减而价值降低。至于欧洲政府，他们还可能会违约。对于由验证人质押而来的代币，要考虑到验证人的恶意行为可能会遭到惩罚的情况。</p>
<p>基于我们的原则，我们选择了一种更简单的方案：不能把所有的代币都质押进来。这意味着一部分（可能 20%）代币会被强制保持可流通的状态。尽管从安全的角度上讲，这个方案不完美，但也没有从根本上影响网络的安全。相比于 100%的质押，也将只可能没收 80%的权益作为赔款。</p>
<p>我们还将会使用一个反向拍卖机制来公平地决定质押代币和流通代币的比例。有兴趣成为验证人的代币持有者可以给权益合约提交一个请求，说明他们希望支付的最小比例。每次会话（会话可能每个小时算一次）开始的时候，系统会根据每个意向验证人的押金和支出比例来填满验证人的插槽。一个可能的算法是从提交押金的验证人中，选择那些押金满足如下条件的人：押金不高于“总押金目标/插槽数量”且不低于“次低押金”的一半。如果不够填满这些插槽，那么我们会迅速降低这个“次低押金”来满足条件。</p>
<h4 id="6-2-2-提名"><a href="#6-2-2-提名" class="headerlink" title="6.2.2 提名"></a>6.2.2 提名</h4><p>用户可以把手中的权益代币非信任地交给一个已激活的验证人，让他们来履行验证人的职责。提名通过一个“批准-投票”系统来完成。每个准提名人可以给权益合约提交一个声明，指出他们信任的可以履行职责的一个或多个验证人的身份。</p>
<p>在每个会话期间，提名人的押金会散布给一个或多个代表他们的验证人。这些验证人的押金是等额分配的。提名人的押金用于验证人承担他们的责任，将能够获得利息或承受相应的扣减。</p>
<h4 id="6-2-3-押金没收-烧毁"><a href="#6-2-3-押金没收-烧毁" class="headerlink" title="6.2.3 押金没收/烧毁"></a>6.2.3 押金没收/烧毁</h4><p>验证人的某些行为会导致惩罚性地没收他们的押金。如果押金降低到允许的最小值，会话就会提前结束，另一个会话开始。一个不完整的将导致惩罚的行为列表：</p>
<ul>
<li>属于一条平行链的验证人小组，却不为该平行链的区块提供合法性验证；</li>
<li>签名了该平行链一个不合法的区块；</li>
<li>不去处理出口队列中被投票为已生效的消息；</li>
<li>不参与到共识流程中；</li>
<li>在中继链两个竞争性的分叉上同时签名。</li>
</ul>
<p>有些行为会威胁到网络的完整性（例如签名不合法的平行链区块，或者签名多个分叉），为了驱逐这些验证人，会没收他们的押金。另外还有一些不那么严重的行为（例如不参与到共识流程中）或者那些无法清晰判别的行为（例如处于一个低效的小组），只会导致一小部分的押金被处罚。在后一种情况中，可以采用一个二级小组的搅拌功能来让恶意节点遭受到比正常节点更多的惩罚。</p>
<p>因为实时同步每条平行链的区块是个非常大的工作，所以在某些情况下（多叉签名和不合法签名），验证人无法很方便地检测到自身的不当行为。在这里有必要指出验证人之外的一些参与方也可以举报这些非法行为，并从中获得奖励，但他们和渔夫还不太一样。</p>
<p>因为有些情况非常严重，我们希望可以很简单地从没收的押金里支付奖金。我们通常倾向于使用烧毁代币的方法进行重分配，而不是采用批量转账的方法。烧币可以从整体上增加代币的价值，也就可以补偿整个网络而不仅是涉及到的特定几方。这主要是作为安全防范机制，只有非常恶劣的行为才会到会非常大金额的惩罚。</p>
<p>很重要的一点是奖金必须足够高才能让网络觉得验证工作是值得做的，当然也不能比成本高太多，否则会招致那些足够有钱的、精心策划的国际级别的犯罪黑客攻击那些不幸的验证人，迫使他们做出非法行为。</p>
<p>规定的奖金也不能比恶意验证人的押金高太多，否则会不正当地激励非法行为：验证人为了奖金自己举报自己。解决方法是要么直接限制成为一个验证人的最小押金量，要么间接教育提名人：如果验证人押金太少，他们可能没有足够的动机来遵守规则。</p>
<h3 id="6-3-平行链的注册"><a href="#6-3-平行链的注册" class="headerlink" title="6.3 平行链的注册"></a>6.3 平行链的注册</h3><p>这个模块用于记录系统中的每条平行链。它是个相对简单的类似数据库的结构，管理着每条链的静态信息和动态信息。</p>
<p>静态信息包括链的索引（一个整数）和验证协议的标识。协议标识用于区分不同的平行链，只有这样，验证人才能运行正确的验证算法 ，然后提交合法的候选块。一个最初的概念验证版本会关注于如何把一个新的验证算法放在客户端中，这样每增加一个新种类的区块链，就需要一次硬分叉。然而在保证严格和高效的情况下，还是有可能不用通过硬分叉就能让验证人知晓新验证算法。一个可能的实现方法就是用一种确定的、本地编译的、平台无关的语言来描述平行链的验证算法，例如 WebAssembly 等。为了验证这种方法的可行性，我们还要做更多的调查，毕竟如果能够避免硬分叉还是会有很大优势的。</p>
<p>动态信息涉及交易路由系统，比如必须对平行链的的入口队列进行全局共识（在下一节讨论）。</p>
<p>必须通过全民公投才能注册新的平行链。这本来可以直接内部管理，但通过一个外部的全民公投合约会更好，因为这个合约还可以用于更多其他场景的治理。关于平行链投票注册系统的具体参数（例如法定人数、多数派的比例）会用形式化证明做成一个不常更新的“主宪法”系统，当然初始阶段也可能只是用传统的方法。具体的公式不在本文的讨论范围内，例如占 2/3 的多数派通过，并且全系统 1/3 的代币都参与了投票才算通过。还有一些暂停和删除平行链的操作。我们希望永远不要暂停一条平行链，但这个设计是为了能应对平行链的一些紧急情况。最明显的情况是由于验证人运行了平行链的多种客户端实现，导致可能无法对某区块达成共识。我们也鼓励验证人使用多种客户端实现，以便能尽早检测到这类事情，防止押金被扣减。</p>
<p>因为暂停操作是个紧急措施，所以会采用验证人动态投票的方式，而不是通过全民公投。对于重启操作，可能直接通过验证人投票，也可能通过全民公投来完成。</p>
<p>删除操作平行链只能通过全民公投来进行，而且要提供一个宽松的平滑退出过渡期，能让它们成为一个独立的区块链或变成其他共识系统的一部分。这个期限可能是几个月，而且最好由平行链根据自身的需求来制定。</p>
<h3 id="6-4-打包中继链区块"><a href="#6-4-打包中继链区块" class="headerlink" title="6.4 打包中继链区块"></a>6.4 打包中继链区块</h3><p>区块打包的过程本质上是共识的过程，也是把基本的数据变得有意义的过程。在一个 PoW 链里，打包有一个同义词叫挖矿。在本方案里，它涉及收集验证人对于区块有效性、可用性、一致性的签名，这些区块包括中继链区块和它所包含的全部平行链的区块。</p>
<p>底层的 BFT 共识算法也不是当前的工作范围。我们不描述它，而是使用一种原语描述一种由共识推动的状态机。最终我们希望能受到一些现有共识算法的启发：Tangaora（Raft 的 BFT 变体）、Tendermint 和 HoneyBadgerBFT。共识算法需要并发地对多条平行链达成共识。假设一旦共识达成，我们就可以不可辩驳地记录哪些人参与了其中。我们也可以在协议内把不正当行为的人缩小到一个小组中，里面仅包含哪些恶意参与者，这样就可以在惩罚时可以降低附带伤害。</p>
<p>以签名声明形式存在的这些证明、中继链的状态树根和交易树根一起存储在中继链的块头里。</p>
<p>对于中继链区块和平行链区块的打包过程是在同一个共识生成机制中，两类块共同组成了中继链的内容：平行链并不是由他们的小组隔离地进行“提交”之后再被收集的。这虽然导致中继链的流程更加复杂，但也让我们可以在一个阶段里就完成整个系统的共识，能够将延迟最小化，并且能支持更加复杂的数据可用性，这在路由流程中将会很有用。</p>
<p>可以用一个简单的表格（二维的）来建模每个参与共识机器的状态。每个参与方（验证者）都有一系列以签名形式存在的来源于其他参与方的信息，描述着每条平行链的候选块和中继链的候选块。这些信息有两部分数据：</p>
<p><strong>可用性（Availability）</strong>：对于出口队列里这个块的已提交交易，验证人是否有足够的信息以便在下一个块正确地验证平行链的候选块？他们可以投 1（知道）或 0（不确定）。当他们投了 1，他们就承诺在后续的投票中也要这么投票。后面的投票和这个不对应会导致惩罚。<br><strong>有效性（Validity）</strong>：平行链的区块是否有效，是否包含了引用的所有的外部数据（比如交易）？这和验证人对平行链的投票相关。他们可以投 1（有效）、-1（无效）或 0（不确定）。只要他们投了非 0，他们就承诺在后续的投票中也要这么投票。后面的投票和这个不对应会导致惩罚。</p>
<p>所有验证人都必须投票；在上面的规则限制下，还可以重新提交投票。共识流程可以像很多标准 BFT 共识算法那样来建模，每条平行链是并行的。除了有很小的概率把少数恶意参与者都被分配到了同一条平行链小组之外，共识算法在整体上还是能支撑网络，最坏的情况也不过只是出现一个或多个无效平行链区块而死锁的情况（何对责任人进行的惩罚）。<br>判断一个独立区块是否有效的基本规则（允许全部的验证人作为一个整体达成共识，然后这些平行链区块就成为中继链上具有一致性的数据引用）：</p>
<ul>
<li>需要有至少三分之二的验证人投票“是”，并且没人投“否”。</li>
<li>需要超过三分之一的验证人对出口队列消息的可用性与否投票“是”。</li>
</ul>
<p>对于有效性而言，如果至少有一个“是”且至少有一个“否”投票，一个特殊的条件就开启了，整个验证人就必须投票决定是否有恶意参与者，或者是否产生了意外的分叉。除了有效和无效之外，还支持投第三种票，等效于同时投了“是”和“否”，表示这个节点有相互冲突的意见。这可能是因为节点所有者运行的多种客户端实现而产生了分歧，也预示着平行链协议可能存在不清楚的地方。</p>
<p>当所有验证人的票都被记录过后，发现赢的那个意见少于一定数量的票（详细参数最多可能是一半，也许更少），那就可以假设平行链发生了意外的硬分叉，这条平行链的共识就会被自动暂停。否则，我们假设就是有恶意行为发生，并惩罚那些给输的那个意见投了“是”票的验证人。<br>结论是只有足够的签名票数才能达成一致性，然后中继链的区块就打包完成了，开始打包下一个区块。</p>
<h3 id="6-5-中继链区块打包的改进"><a href="#6-5-中继链区块打包的改进" class="headerlink" title="6.5 中继链区块打包的改进"></a>6.5 中继链区块打包的改进</h3><p>打包区块的方法确保着系统的正常运行，因为每条平行链的关键信息都要由超过三分之一的验证人来保证可用性，所以它并不能很好地伸缩。这意味着随着更多平行链的增加，每个验证人的工作也会增加。</p>
<p>在开放的共识网络中，如何保证数据的可用性还是个有待解决的问题，然而还是有一些方法可以缓解验证人节点的性能瓶颈。一个简单的方案是：验证人只负责验证数据的可用性，那他们就没必要自己真正地存储、通信和复制数据。第二个方案是数据隔离，这个方案很可能和收集人如何组织数据相关，网络可以对收集人有一定的利息或收入激励，让他们保证提供给验证人的数据是可用的。</p>
<p>然而，这个方案也许可以带来一点伸缩性，但仍没有解决根本问题。因为添加更多平行链通常需要增加验证人，网络资源的消耗（主要是带宽）以链总数的平方的速度增长，长期来看这是不可持续的。</p>
<p>最终，我们可能会思考对于保证共识网络安全的根本限制，网络对带宽的需求增长速度是验证人数乘以消息总进入数。我们不能信任那些将数据分开在不同节点存储的共识网络，因为这会将数据和运算分离。</p>
<h4 id="6-5-1-延迟性介绍"><a href="#6-5-1-延迟性介绍" class="headerlink" title="6.5.1 延迟性介绍"></a>6.5.1 延迟性介绍</h4><p>简化这个规则的方法是先了解即时性的概念。33% + 1 的验证人最终（eventually）需要对数据的有效性进行投票，而不是立刻（immediately）投票，我们可以更好地利用数据指数级传播的特性，来帮助应对数据通信的峰值。一个合理的等式（尽管未证明）：</p>
<p>（1）在目前的模型下，系统的规模只有随着链的个数而伸缩，才能保证数据的分布式运算；因为每个链至少需要一个验证人，对于可用性投票的复杂度，我们把它降到了只和验证人个数呈线性关系。现在验证人数可以和链个数类似的增长，不再是：</p>
<p>（2） 延迟 = 数量^2</p>
<p>这意味着随着系统增长，网络内带宽和延迟性的增长是可知的，但达到最终确定性所需的区块数目仍然是以平方增长。这个问题将会继续困扰我们，也可能迫使我们打造一个“非平层”（non-flat）的架构，也就是会有很多按层级结构排列的Polkadot 链，通过一个树形的结构来路由消息。</p>
<h4 id="6-5-2-公众参与"><a href="#6-5-2-公众参与" class="headerlink" title="6.5.2 公众参与"></a>6.5.2 公众参与</h4><p>微意见（micro-complaints）系统是一种可以促进公众参与的方式。可以有一些类似于渔夫的外部参与方来监管验证人。他们的任务是找到提供了非可用数据的验证人。他们可以给其他的验证人提交一个微意见。这个方案需要用 PoW 或押金机制来防止女巫攻击，否则它会让整个系统失效。</p>
<h4 id="6-5-3-可用性保证人"><a href="#6-5-3-可用性保证人" class="headerlink" title="6.5.3 可用性保证人"></a>6.5.3 可用性保证人</h4><p>最终的一个方案是从验证人里提名出第二个小组作为可用性保证人（Availability Guarantors）。他们也需要和普通验证人那样交押金，而且有可能来源于同一个组（会在一个长周期里选择他们，至少也是一个会话周期）。和普通验证人不同的是，他们不需要在各条平行链间切换，而只需要形成一个单一的小组，监管所有重要跨链数据的可用性。</p>
<p>这个方案还有个优势是能缓解验证人数和链个数之间的等式关系。链个数可以最终增长（与原始链的验证人小组一起），然而各参与方仍可以保持次线性增长或常量增长，尤其是那些参与数据可用性验证的人。</p>
<h4 id="6-5-4-收集人设置"><a href="#6-5-4-收集人设置" class="headerlink" title="6.5.4 收集人设置"></a>6.5.4 收集人设置</h4><p>系统需要保证的一个重要方面是：合理地选择那些制造平行链区块的收集人。如果一条平行链由某个收集人控制了，那么外部数据是否可用就会变得不那么明显，这个人就可以比较简单地发动攻击。</p>
<p>为了尽可能地广泛分配收集人，我们可以用伪随机的方法来人工衡量平行链区块的权重。在第一个示例中，我们希望验证人倾向于选择权重更大的候选块，这是共识机制的一个重要部分。我们也必须激励验证人找到最大权重的候选块，验证人可以把他们的奖励按比例分配给这些候选块。</p>
<p>在共识系统里，为了确保收集人的区块被选中的机会是平等的，我们用一个连接所有收集人的随机数生成器来决定每个候选块的权重。例如用收集人的地址和一些密码学安全的伪随机数做异或（XOR）运算来决定最优的块（获胜票）。这给了每个收集人（更准确地说是每个收集人地址）随机公平地打败别人的机会。</p>
<p>验证人通过女巫攻击来生成一个最接近于获胜票的地址，为了阻止这种情况，我们会给收集人的地址加上一些惰性。一个很简单的方法是需要他们的地址有基本的余额，另一个更优雅的方式是综合考虑地址的余额来计算获胜的概率。这里还没有完成建模，我们很可能会让很少余额的人也可以成为收集人。</p>
<h4 id="6-5-5-区块超重"><a href="#6-5-5-区块超重" class="headerlink" title="6.5.5 区块超重"></a>6.5.5 区块超重</h4><p>如果一个验证人集合被攻击了，他们可能会生成一个虽然有效但要花费大量时间来执行的区块。这个问题来源于一些特定的难解数据题，比如大质数因式分解难题等，验证人小组可能需要非常长的时间才能解出答案，如果有人知道一些捷径，他们的候选块就有巨大的获胜优势。如果一个收集人知道那个信息，而其他人都在忙着计算老的块，那么他就<br>有很大的优势让他的候选块获胜。我们称这种叫超重（overweight）块。</p>
<p>为了防止验证人提交这些大幅超出普通区块的超重块，我们需要添加一些警告：因为执行一个区块要花费的时间是相对的（根据它超重的程度），所以最终可能的投票结果会有三种：第一种是这个区块绝对没有超重，超过 2/3 的验证人声明他们可以在一定时间内算完（例如出块时间的 50%）；另一种是这个区块绝对超重了，超过 2/3 的验证人声明他们无法在限定的时间内执行完这个区块；再一种就是意见分歧基本持平，这种情况下我们会做一些惩罚。</p>
<p>为了保证验证人能预测他们提交的区块是否超重，他们可能需要公布自己在每个块上的执行表现。经过一段时间后，他们就可以通过和其他节点的比较来评估自己处理器的性能。</p>
<h4 id="6-5-6-收集人保险"><a href="#6-5-6-收集人保险" class="headerlink" title="6.5.6 收集人保险"></a>6.5.6 收集人保险</h4><p>还有一个问题留给了验证人：为了检查收集人区块的有效性，他们不能像 PoW 网络那样，而是必须自己计算里面的交易。恶意收集人可以填充非法或超重的区块给验证人，通过让他们受害（浪费他们的资源）来获取大量的潜在机会成本。</p>
<p>为了预防这个，我们为验证人提供了一个简单的策略。第一：发给验证人的平行链候选块必须要用有钱的中继链账户签名，如果不这么做，验证人会立即丢弃这个块。第二：会用组合算法（或乘法）对这些候选块进行排序，因素包括高于一定限额的账户余额、收集人过去成功提交的区块数（除去那些有惩罚的）、和获胜票的接近程度。这里的限额应该等于提交非法块的惩罚金。</p>
<p>为了警示收集人不要发送非法或超重的交易给验证人，任何验证人都可以在下一个区块中打包一个交易，指出那个非法的区块，并将那个收集人部分或全部的余额都转给那个受害的验证人。这种交易的优先级高于其他交易，使得收集人不能在惩罚之前转走他的余额。惩罚金额可能是动态决定的，也很可能是验证人区块奖励的一部分。为了阻止验证人任意没收收集人的钱，收集人可以对验证人的决定进行上诉，成立一个由验证人随机组成的陪审团，并交一些押金。如果陪审团发现验证人是合理的，那这笔押金就给陪审团了。如果是不合理的，押金退回给该收集人，而验证人要受到惩罚（因为验证人是核心角色，惩罚会比较重）。</p>
<h3 id="6-6-跨链交易路由"><a href="#6-6-跨链交易路由" class="headerlink" title="6.6 跨链交易路由"></a>6.6 跨链交易路由</h3><p>跨链交易路由是中继链和其验证人的核心功能。这里管理着主要的逻辑：一个提交的交易（简言之为“提交”）是如何从一个来源（source）平行链的出口被强制地路由到另一个目标（destination）平行链里，而且无需任何信任人。</p>
<p>我们很小心地选择了上面的词语；在来源平行链里，我们无需一个明确约束这个提交的交易。我们模型里的唯一约束是：平行链必须尽力按照全部的出口能力打包，这些提交就是他们区块执行的结果。</p>
<p>我们用一个先进先出（FIFO）的队列组织这些提交。作为路由基准（routing base）的队列个数可能在 16 个左右。这个数字代表着我们可以直接支持的平行链性能，而不用采用多相（multi-phase）路由。Polkadot 一开始会支持这种直接路由，然而我们也可能会采用一种多相路由操作（超路由 hyper-routing）作为将来系统伸缩的方式。<br>我们假设所有参与方都知道下两个区块 n，n+1 的验证人分组情况。概括而言，路由系统有如下阶段：</p>
<ul>
<li>收集人s：合约成员中的验证人 V[n][S]。</li>
<li>收集人s：FOR EACH 小组s：确保合约里有至少一个验证人  V[n][S]。</li>
<li>收集人s：FOR EACH 小组s：假设出口[n-1][s][S]是可用的（上个区块里所有对 S 提交的数据）</li>
<li>收集人s：为 S 构造候选块 b：（b.header, b.ext, b.proof, b.receipt, b.egress）。</li>
<li>收集</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>Polkadot</tag>
        <tag>跨链</tag>
      </tags>
  </entry>
</search>
